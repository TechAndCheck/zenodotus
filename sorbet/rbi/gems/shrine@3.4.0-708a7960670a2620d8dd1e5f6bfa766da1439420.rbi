# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `shrine` gem.
# Please instead update this file by running `bin/tapioca gem shrine`.


# Core class that handles uploading files to specified storage.
#
# source://shrine//lib/shrine/uploaded_file.rb#7
class Shrine
  include ::Shrine::InstanceMethods
  extend ::Shrine::ClassMethods

  class << self
    # source://shrine//lib/shrine/version.rb#4
    def version; end
  end
end

# Core class that handles attaching files. It uses Shrine and
# Shrine::UploadedFile objects internally.
#
# source://shrine//lib/shrine/attacher.rb#6
class Shrine::Attacher
  include ::Shrine::Attacher::InstanceMethods
  extend ::Shrine::Attacher::ClassMethods
end

# source://shrine//lib/shrine/attacher.rb#9
module Shrine::Attacher::ClassMethods
  # Initializes the attacher from a data hash generated from `Attacher#data`.
  #
  #     attacher = Attacher.from_data({ "id" => "...", "storage" => "...", "metadata" => { ... } })
  #     attacher.file #=> #<Shrine::UploadedFile>
  #
  # source://shrine//lib/shrine/attacher.rb#25
  def from_data(data, **options); end

  # Since Attacher is anonymously subclassed when Shrine is subclassed,
  # and then assigned to a constant of the Shrine subclass, make inspect
  # reflect the likely name for the class.
  #
  # source://shrine//lib/shrine/attacher.rb#17
  def inspect; end

  # Returns the Shrine class that this attacher class is namespaced
  # under.
  #
  # source://shrine//lib/shrine/attacher.rb#12
  def shrine_class; end

  # Returns the Shrine class that this attacher class is namespaced
  # under.
  #
  # source://shrine//lib/shrine/attacher.rb#12
  def shrine_class=(_arg0); end
end

# source://shrine//lib/shrine/attacher.rb#32
module Shrine::Attacher::InstanceMethods
  # Initializes the attached file, temporary and permanent storage.
  #
  # source://shrine//lib/shrine/attacher.rb#41
  def initialize(file: T.unsafe(nil), cache: T.unsafe(nil), store: T.unsafe(nil)); end

  # Calls #attach_cached, but skips if value is an empty string (this is
  # useful when the uploaded file comes from form fields). Forwards any
  # additional options to #attach_cached.
  #
  #     attacher.assign(File.open(...))
  #     attacher.assign(File.open(...), metadata: { "foo" => "bar" })
  #     attacher.assign('{"id":"...","storage":"cache","metadata":{...}}')
  #     attacher.assign({ "id" => "...", "storage" => "cache", "metadata" => {} })
  #
  #     # ignores the assignment when a blank string is given
  #     attacher.assign("")
  #
  # source://shrine//lib/shrine/attacher.rb#70
  def assign(value, **options); end

  # Uploads given IO object and changes the uploaded file.
  #
  #     # uploads the file to permanent storage
  #     attacher.attach(io)
  #
  #     # uploads the file to specified storage
  #     attacher.attach(io, storage: :other_store)
  #
  #     # forwards additional options to the uploader
  #     attacher.attach(io, upload_options: { acl: "public-read" }, metadata: { "foo" => "bar" })
  #
  #     # removes the attachment
  #     attacher.attach(nil)
  #
  # source://shrine//lib/shrine/attacher.rb#116
  def attach(io, storage: T.unsafe(nil), **options); end

  # Sets an existing cached file, or uploads an IO object to temporary
  # storage and sets it via #attach. Forwards any additional options to
  # #attach.
  #
  #     # upload file to temporary storage and set the uploaded file.
  #     attacher.attach_cached(File.open(...))
  #
  #     # foward additional options to the uploader
  #     attacher.attach_cached(File.open(...), metadata: { "foo" => "bar" })
  #
  #     # sets an existing cached file from JSON data
  #     attacher.attach_cached('{"id":"...","storage":"cache","metadata":{...}}')
  #
  #     # sets an existing cached file from Hash data
  #     attacher.attach_cached({ "id" => "...", "storage" => "cache", "metadata" => {} })
  #
  # source://shrine//lib/shrine/attacher.rb#95
  def attach_cached(value, **options); end

  # Returns whether a file is attached.
  #
  #     attacher.attach(io)
  #     attacher.attached? #=> true
  #
  #     attacher.attach(nil)
  #     attacher.attached? #=> false
  #
  # @return [Boolean]
  #
  # source://shrine//lib/shrine/attacher.rb#272
  def attached?; end

  # Returns the uploader that is used for the temporary storage.
  #
  # source://shrine//lib/shrine/attacher.rb#55
  def cache; end

  # Returns the temporary storage identifier.
  #
  # source://shrine//lib/shrine/attacher.rb#50
  def cache_key; end

  # Returns whether the file is uploaded to temporary storage.
  #
  #     attacher.cached?       # checks current file
  #     attacher.cached?(file) # checks given file
  #
  # @return [Boolean]
  #
  # source://shrine//lib/shrine/attacher.rb#280
  def cached?(file = T.unsafe(nil)); end

  # Sets the uploaded file with dirty tracking, and runs validations.
  #
  #     attacher.change(uploaded_file)
  #     attacher.file #=> #<Shrine::UploadedFile>
  #     attacher.changed? #=> true
  #
  # source://shrine//lib/shrine/attacher.rb#219
  def change(file); end

  # Returns whether the attachment has changed.
  #
  #     attacher.changed? #=> false
  #     attacher.attach(file)
  #     attacher.changed? #=> true
  #
  # @return [Boolean]
  #
  # source://shrine//lib/shrine/attacher.rb#261
  def changed?; end

  # Returns options that are automatically forwarded to the uploader.
  # Can be modified with additional data.
  #
  # source://shrine//lib/shrine/attacher.rb#38
  def context; end

  # Generates serializable data for the attachment.
  #
  #     attacher.data #=> { "id" => "...", "storage" => "...", "metadata": { ... } }
  #
  # source://shrine//lib/shrine/attacher.rb#295
  def data; end

  # Destroys the attachment.
  #
  #     attacher.file.exists? #=> true
  #     attacher.destroy
  #     attacher.file.exists? #=> false
  #
  # source://shrine//lib/shrine/attacher.rb#210
  def destroy; end

  # Destroys the attached file if it exists and is uploaded to permanent
  # storage.
  #
  #     attacher.file.exists? #=> true
  #     attacher.destroy_attached
  #     attacher.file.exists? #=> false
  #
  # source://shrine//lib/shrine/attacher.rb#201
  def destroy_attached; end

  # If a new file was attached, deletes previously attached file if any.
  #
  #     previous_file = attacher.file
  #     attacher.attach(file)
  #     attacher.destroy_previous
  #     previous_file.exists? #=> false
  #
  # source://shrine//lib/shrine/attacher.rb#191
  def destroy_previous; end

  # Returns the attached uploaded file.
  #
  # source://shrine//lib/shrine/attacher.rb#34
  def file; end

  # Returns attached file or raises an exception if no file is attached.
  #
  # source://shrine//lib/shrine/attacher.rb#321
  def file!; end

  # Saves the given uploaded file to an instance variable.
  #
  #     attacher.file = uploaded_file
  #     attacher.file #=> #<Shrine::UploadedFile>
  #
  # source://shrine//lib/shrine/attacher.rb#312
  def file=(file); end

  # Deletes any previous file and promotes newly attached cached file.
  # It also clears any dirty tracking.
  #
  #     # promoting cached file
  #     attacher.assign(io)
  #     attacher.cached? #=> true
  #     attacher.finalize
  #     attacher.stored?
  #
  #     # deleting previous file
  #     previous_file = attacher.file
  #     previous_file.exists? #=> true
  #     attacher.assign(io)
  #     attacher.finalize
  #     previous_file.exists? #=> false
  #
  #     # clearing dirty tracking
  #     attacher.assign(io)
  #     attacher.changed? #=> true
  #     attacher.finalize
  #     attacher.changed? #=> false
  #
  # source://shrine//lib/shrine/attacher.rb#143
  def finalize; end

  # Returns the attached file.
  #
  #     # when a file is attached
  #     attacher.get #=> #<Shrine::UploadedFile>
  #
  #     # when no file is attached
  #     attacher.get #=> nil
  #
  # source://shrine//lib/shrine/attacher.rb#240
  def get; end

  # Loads the uploaded file from data generated by `Attacher#data`.
  #
  #     attacher.file #=> nil
  #     attacher.load_data({ "id" => "...", "storage" => "...", "metadata" => { ... } })
  #     attacher.file #=> #<Shrine::UploadedFile>
  #
  # source://shrine//lib/shrine/attacher.rb#304
  def load_data(data); end

  # Uploads current file to permanent storage and sets the stored file.
  #
  #     attacher.cached? #=> true
  #     attacher.promote
  #     attacher.stored? #=> true
  #
  # source://shrine//lib/shrine/attacher.rb#170
  def promote(storage: T.unsafe(nil), **options); end

  # If a new cached file has been attached, uploads it to permanent storage.
  # Any additional options are forwarded to #promote.
  #
  #     attacher.assign(io)
  #     attacher.cached? #=> true
  #     attacher.promote_cached
  #     attacher.stored? #=> true
  #
  # source://shrine//lib/shrine/attacher.rb#161
  def promote_cached(**options); end

  # Plugins can override this if they want something to be done in a
  # "before save" callback.
  #
  # source://shrine//lib/shrine/attacher.rb#151
  def save; end

  # Sets the uploaded file.
  #
  #     attacher.set(uploaded_file)
  #     attacher.file #=> #<Shrine::UploadedFile>
  #     attacher.changed? #=> false
  #
  # source://shrine//lib/shrine/attacher.rb#229
  def set(file); end

  # Returns the Shrine class that this attacher's class is namespaced
  # under.
  #
  # source://shrine//lib/shrine/attacher.rb#338
  def shrine_class; end

  # Returns the uploader that is used for the permanent storage.
  #
  # source://shrine//lib/shrine/attacher.rb#57
  def store; end

  # Returns the permanent storage identifier.
  #
  # source://shrine//lib/shrine/attacher.rb#52
  def store_key; end

  # Returns whether the file is uploaded to permanent storage.
  #
  #     attacher.stored?       # checks current file
  #     attacher.stored?(file) # checks given file
  #
  # @return [Boolean]
  #
  # source://shrine//lib/shrine/attacher.rb#288
  def stored?(file = T.unsafe(nil)); end

  # Delegates to `Shrine.upload`, passing the #context.
  #
  #     # upload file to specified storage
  #     attacher.upload(io, :store) #=> #<Shrine::UploadedFile>
  #
  #     # pass additional options for the uploader
  #     attacher.upload(io, :store, metadata: { "foo" => "bar" })
  #
  # source://shrine//lib/shrine/attacher.rb#181
  def upload(io, storage = T.unsafe(nil), **options); end

  # Converts JSON or Hash data into a Shrine::UploadedFile object.
  #
  #     attacher.uploaded_file('{"id":"...","storage":"...","metadata":{...}}')
  #     #=> #<Shrine::UploadedFile ...>
  #
  #     attacher.uploaded_file({ "id" => "...", "storage" => "...", "metadata" => {} })
  #     #=> #<Shrine::UploadedFile ...>
  #
  # source://shrine//lib/shrine/attacher.rb#332
  def uploaded_file(value); end

  # If a file is attached, returns the uploaded file URL, otherwise returns
  # nil. Any options are forwarded to the storage.
  #
  #     attacher.file = file
  #     attacher.url #=> "https://..."
  #
  #     attacher.file = nil
  #     attacher.url #=> nil
  #
  # source://shrine//lib/shrine/attacher.rb#252
  def url(**options); end

  private

  # Converts a String or Hash value into an UploadedFile object and ensures
  # it's uploaded to temporary storage.
  #
  #     # from JSON data
  #     attacher.cached('{"id":"...","storage":"cache","metadata":{...}}')
  #     #=> #<Shrine::UploadedFile>
  #
  #     # from Hash data
  #     attacher.cached({ "id" => "...", "storage" => "cache", "metadata" => { ... } })
  #     #=> #<Shrine::UploadedFile>
  #
  # source://shrine//lib/shrine/attacher.rb#354
  def cached(value, **_arg1); end

  # Whether assigning the given file is considered a change.
  #
  # @return [Boolean]
  #
  # source://shrine//lib/shrine/attacher.rb#377
  def change?(file); end

  # Whether attached file should be deleted.
  #
  # @return [Boolean]
  #
  # source://shrine//lib/shrine/attacher.rb#372
  def destroy?; end

  # Whether attached file should be uploaded to permanent storage.
  #
  # @return [Boolean]
  #
  # source://shrine//lib/shrine/attacher.rb#367
  def promote?; end

  # Returns whether the file is uploaded to specified storage.
  #
  # @return [Boolean]
  #
  # source://shrine//lib/shrine/attacher.rb#382
  def uploaded?(file, storage_key); end
end

# Core class that provides an attachment interface for a specified attribute
# name, which can be added to model/entity classes. The model/entity plugins
# define the main interface, which delegates to a Shrine::Attacher object.
#
# source://shrine//lib/shrine/attachment.rb#7
class Shrine::Attachment < ::Module
  include ::Shrine::Attachment::InstanceMethods
  extend ::Shrine::Attachment::ClassMethods
end

# source://shrine//lib/shrine/attachment.rb#10
module Shrine::Attachment::ClassMethods
  # Shorthand for `Attachment.new`.
  #
  #   Shrine::Attachment[:image]
  #
  # source://shrine//lib/shrine/attachment.rb#25
  def [](*args, **options); end

  # Since Attachment is anonymously subclassed when Shrine is subclassed,
  # and then assigned to a constant of the Shrine subclass, make inspect
  # reflect the likely name for the class.
  #
  # source://shrine//lib/shrine/attachment.rb#18
  def inspect; end

  # Returns the Shrine class that this attachment class is
  # namespaced under.
  #
  # source://shrine//lib/shrine/attachment.rb#13
  def shrine_class; end

  # Returns the Shrine class that this attachment class is
  # namespaced under.
  #
  # source://shrine//lib/shrine/attachment.rb#13
  def shrine_class=(_arg0); end
end

# source://shrine//lib/shrine/attachment.rb#30
module Shrine::Attachment::InstanceMethods
  # Instantiates an attachment module for a given attribute name, which
  # can then be included to a model class. Second argument will be passed
  # to an attacher module.
  #
  # source://shrine//lib/shrine/attachment.rb#34
  def initialize(name, **options); end

  # Returns name of the attachment this module provides.
  #
  # source://shrine//lib/shrine/attachment.rb#40
  def attachment_name; end

  # Returns class name with attachment name included.
  #
  #     Shrine::Attachment.new(:image).to_s #=> "#<Shrine::Attachment(image)>"
  #
  # source://shrine//lib/shrine/attachment.rb#52
  def inspect; end

  # Returns options that are to be passed to the Attacher.
  #
  # source://shrine//lib/shrine/attachment.rb#45
  def options; end

  # Returns the Shrine class that this attachment's class is namespaced
  # under.
  #
  # source://shrine//lib/shrine/attachment.rb#59
  def shrine_class; end

  # Returns class name with attachment name included.
  #
  #     Shrine::Attachment.new(:image).to_s #=> "#<Shrine::Attachment(image)>"
  #
  # source://shrine//lib/shrine/attachment.rb#52
  def to_s; end
end

# source://shrine//lib/shrine.rb#36
module Shrine::ClassMethods
  # Generates an instance of Shrine::Attachment to be included in the
  # model class. Example:
  #
  #     class Photo
  #       include Shrine::Attachment(:image) # creates a Shrine::Attachment object
  #     end
  #
  # source://shrine//lib/shrine.rb#98
  def Attachment(name, **args); end

  # Generates an instance of Shrine::Attachment to be included in the
  # model class. Example:
  #
  #     class Photo
  #       include Shrine::Attachment(:image) # creates a Shrine::Attachment object
  #     end
  #
  # source://shrine//lib/shrine.rb#98
  def [](name, **args); end

  # Generates an instance of Shrine::Attachment to be included in the
  # model class. Example:
  #
  #     class Photo
  #       include Shrine::Attachment(:image) # creates a Shrine::Attachment object
  #     end
  #
  # source://shrine//lib/shrine.rb#98
  def attachment(name, **args); end

  # Prints a deprecation warning to the logger.
  #
  # source://shrine//lib/shrine.rb#157
  def deprecation(message); end

  # Retrieves the storage under the given identifier (can be a Symbol or
  # a String), raising Shrine::Error if the storage is missing.
  #
  # source://shrine//lib/shrine.rb#88
  def find_storage(name); end

  # When inheriting Shrine, copy the instance variables into the subclass,
  # and create subclasses of core classes.
  #
  # source://shrine//lib/shrine.rb#48
  def inherited(subclass); end

  # A logger instance.
  #
  # source://shrine//lib/shrine.rb#44
  def logger; end

  # A logger instance.
  #
  # source://shrine//lib/shrine.rb#44
  def logger=(_arg0); end

  # Generic options for this class, plugins store their options here.
  #
  # source://shrine//lib/shrine.rb#38
  def opts; end

  # Load a new plugin into the current class. A plugin can be a module
  # which is used directly, or a symbol representing a registered plugin
  # which will be required and then loaded.
  #
  #     Shrine.plugin MyPlugin
  #     Shrine.plugin :my_plugin
  #
  # source://shrine//lib/shrine.rb#71
  def plugin(plugin, *args, **kwargs, &block); end

  # A hash of storages with their symbol identifiers.
  #
  # source://shrine//lib/shrine.rb#41
  def storages; end

  # A hash of storages with their symbol identifiers.
  #
  # source://shrine//lib/shrine.rb#41
  def storages=(_arg0); end

  # Uploads the file to the specified storage. It delegates to `Shrine#upload`.
  #
  #     Shrine.upload(io, :store) #=> #<Shrine::UploadedFile>
  #
  # source://shrine//lib/shrine.rb#107
  def upload(io, storage, **options); end

  # Instantiates a Shrine::UploadedFile from a hash, and optionally
  # yields the returned object.
  #
  #     data = { "storage" => "cache", "id" => "abc123.jpg", "metadata" => {} }
  #     Shrine.uploaded_file(data) #=> #<Shrine::UploadedFile>
  #
  # source://shrine//lib/shrine.rb#116
  def uploaded_file(object); end

  # Prints a warning to the logger.
  #
  # source://shrine//lib/shrine.rb#152
  def warn(message); end

  # Temporarily converts an IO-like object into a file. If the input IO
  # object is already a file, it simply yields it to the block, otherwise
  # it copies IO content into a Tempfile object which is then yielded and
  # afterwards deleted.
  #
  #     Shrine.with_file(io) { |file| file.path }
  #
  # source://shrine//lib/shrine.rb#136
  def with_file(io); end

  private

  # Deep duplicates a nested hash of options.
  #
  # source://shrine//lib/shrine.rb#164
  def deep_dup(collection); end
end

# A generic exception used by Shrine.
#
# source://shrine//lib/shrine.rb#17
class Shrine::Error < ::StandardError; end

# Raised by the storage in the #open method.
#
# source://shrine//lib/shrine.rb#28
class Shrine::FileNotFound < ::Shrine::Error; end

# source://shrine//lib/shrine.rb#177
module Shrine::InstanceMethods
  # Accepts a storage symbol registered in `Shrine.storages`.
  #
  #     Shrine.new(:store)
  #
  # source://shrine//lib/shrine.rb#184
  def initialize(storage_key); end

  # Extracts filename, size and MIME type from the file, which is later
  # accessible through UploadedFile#metadata.
  #
  # source://shrine//lib/shrine.rb#228
  def extract_metadata(io, **options); end

  # Generates a unique location for the uploaded file, preserving the
  # file extension. Can be overriden in uploaders for generating custom
  # location.
  #
  # source://shrine//lib/shrine.rb#222
  def generate_location(io, metadata: T.unsafe(nil), **options); end

  # The class-level options hash. This should probably not be modified at
  # the instance level.
  #
  # source://shrine//lib/shrine.rb#238
  def opts; end

  # Returns the storage object referenced by the identifier.
  #
  # source://shrine//lib/shrine.rb#191
  def storage; end

  # The symbol identifier for the storage used by the uploader.
  #
  # source://shrine//lib/shrine.rb#179
  def storage_key; end

  # The main method for uploading files. Takes an IO-like object and an
  # optional context hash (used internally by Shrine::Attacher). It calls
  # user-defined #process, and afterwards it calls #store. The `io` is
  # closed after upload.
  #
  #   uploader.upload(io)
  #   uploader.upload(io, metadata: { "foo" => "bar" })           # add metadata
  #   uploader.upload(io, location: "path/to/file")               # specify location
  #   uploader.upload(io, upload_options: { acl: "public-read" }) # add upload options
  #
  # source://shrine//lib/shrine.rb#204
  def upload(io, **options); end

  private

  # Asserts that the object is a valid IO object, specifically that it
  # responds to `#read`, `#eof?`, `#rewind`, `#size` and `#close`. If the
  # object doesn't respond to one of these methods, a Shrine::InvalidFile
  # error is raised.
  #
  # @raise [InvalidFile]
  #
  # source://shrine//lib/shrine.rb#308
  def _enforce_io(io); end

  # source://shrine//lib/shrine.rb#244
  def _upload(io, location:, metadata:, upload_options: T.unsafe(nil), close: T.unsafe(nil), delete: T.unsafe(nil), **_arg6); end

  # Generates a basic location for an uploaded file
  #
  # source://shrine//lib/shrine.rb#274
  def basic_location(io, metadata:); end

  # Attempts to extract the appropriate filename from the IO object.
  #
  # source://shrine//lib/shrine.rb#252
  def extract_filename(io); end

  # Attempts to extract the MIME type from the IO object.
  #
  # source://shrine//lib/shrine.rb#261
  def extract_mime_type(io); end

  # Extracts the filesize from the IO object.
  #
  # source://shrine//lib/shrine.rb#269
  def extract_size(io); end

  # Generates a unique identifier that can be used for a location.
  #
  # source://shrine//lib/shrine.rb#314
  def generate_uid(io); end

  # Retrieves the location for the given IO and context. First it looks
  # for the `:location` option, otherwise it calls #generate_location.
  #
  # source://shrine//lib/shrine.rb#299
  def get_location(io, location: T.unsafe(nil), **options); end

  # If the IO object is a Shrine::UploadedFile, it simply copies over its
  # metadata, otherwise it calls #extract_metadata.
  #
  # source://shrine//lib/shrine.rb#284
  def get_metadata(io, metadata: T.unsafe(nil), **options); end
end

# Raised when a file is not a valid IO.
#
# source://shrine//lib/shrine.rb#21
class Shrine::InvalidFile < ::Shrine::Error
  # @return [InvalidFile] a new instance of InvalidFile
  #
  # source://shrine//lib/shrine.rb#22
  def initialize(io, missing_methods); end
end

# Module in which all Shrine plugins should be stored. Also contains logic
# for registering and loading plugins.
#
# source://shrine//lib/shrine/plugins.rb#6
module Shrine::Plugins
  class << self
    # Delegate call to the plugin in a way that works across Ruby versions.
    #
    # source://shrine//lib/shrine/plugins.rb#33
    def configure(plugin, uploader, *args, **kwargs, &block); end

    # Delegate call to the plugin in a way that works across Ruby versions.
    #
    # source://shrine//lib/shrine/plugins.rb#22
    def load_dependencies(plugin, uploader, *args, **kwargs, &block); end

    # If the registered plugin already exists, use it. Otherwise, require it
    # and return it. This raises a LoadError if such a plugin doesn't exist,
    # or a Shrine::Error if it exists but it does not register itself
    # correctly.
    #
    # source://shrine//lib/shrine/plugins.rb#13
    def load_plugin(name); end

    # Register the given plugin with Shrine, so that it can be loaded using
    # `Shrine.plugin` with a symbol. Should be used by plugin files. Example:
    #
    #     Shrine::Plugins.register_plugin(:plugin_name, PluginModule)
    #
    # source://shrine//lib/shrine/plugins.rb#47
    def register_plugin(name, mod); end
  end
end

# Core class that represents a file uploaded to a storage.
#
# source://shrine//lib/shrine/uploaded_file.rb#9
class Shrine::UploadedFile
  include ::Shrine::UploadedFile::InstanceMethods
  extend ::Shrine::UploadedFile::ClassMethods
end

# source://shrine//lib/shrine/uploaded_file.rb#12
module Shrine::UploadedFile::ClassMethods
  # Since UploadedFile is anonymously subclassed when Shrine is subclassed,
  # and then assigned to a constant of the Shrine subclass, make inspect
  # reflect the likely name for the class.
  #
  # source://shrine//lib/shrine/uploaded_file.rb#19
  def inspect; end

  # Returns the Shrine class that this file class is namespaced under.
  #
  # source://shrine//lib/shrine/uploaded_file.rb#14
  def shrine_class; end

  # Returns the Shrine class that this file class is namespaced under.
  #
  # source://shrine//lib/shrine/uploaded_file.rb#14
  def shrine_class=(_arg0); end
end

# source://shrine//lib/shrine/uploaded_file.rb#24
module Shrine::UploadedFile::InstanceMethods
  # Initializes the uploaded file with the given data hash.
  #
  # source://shrine//lib/shrine/uploaded_file.rb#35
  def initialize(data); end

  # Returns true if the other UploadedFile is uploaded to the same
  # storage and it has the same #id.
  #
  # source://shrine//lib/shrine/uploaded_file.rb#225
  def ==(other); end

  # Shorthand for accessing metadata values.
  #
  # source://shrine//lib/shrine/uploaded_file.rb#71
  def [](key); end

  # Conform to ActiveSupport's JSON interface.
  #
  # source://shrine//lib/shrine/uploaded_file.rb#214
  def as_json(*args); end

  # Part of complying to the IO interface. It delegates to the internally
  # opened IO object.
  #
  # source://shrine//lib/shrine/uploaded_file.rb#171
  def close; end

  # The MIME type of the uploaded file.
  #
  # source://shrine//lib/shrine/uploaded_file.rb#65
  def content_type; end

  # Returns serializable hash representation of the uploaded file.
  #
  # source://shrine//lib/shrine/uploaded_file.rb#219
  def data; end

  # Calls `#delete` on the storage, which deletes the file from the
  # storage.
  #
  # source://shrine//lib/shrine/uploaded_file.rb#198
  def delete; end

  # Streams content into a newly created Tempfile and returns it.
  #
  # If a block is given, the opened Tempfile object is yielded to the
  # block, and at the end of the block it's automatically closed and
  # deleted. In this case the return value of the method is the block
  # return value.
  #
  # If no block is given, the opened Tempfile is returned.
  #
  #     uploaded_file.download
  #     #=> #<File:/var/folders/.../20180302-33119-1h1vjbq.jpg>
  #
  #     # or
  #
  #     uploaded_file.download { |tempfile| tempfile.read } # tempfile is deleted
  #
  # source://shrine//lib/shrine/uploaded_file.rb#121
  def download(**options); end

  # Part of complying to the IO interface. It delegates to the internally
  # opened IO object.
  #
  # @return [Boolean]
  #
  # source://shrine//lib/shrine/uploaded_file.rb#159
  def eof?; end

  # Returns true if the other UploadedFile is uploaded to the same
  # storage and it has the same #id.
  #
  # source://shrine//lib/shrine/uploaded_file.rb#225
  def eql?(other); end

  # Calls `#exists?` on the storage, which checks whether the file exists
  # on the storage.
  #
  # @return [Boolean]
  #
  # source://shrine//lib/shrine/uploaded_file.rb#187
  def exists?; end

  # The extension derived from #id if present, otherwise it's derived
  # from #original_filename.
  #
  # source://shrine//lib/shrine/uploaded_file.rb#52
  def extension; end

  # Enables using UploadedFile objects as hash keys.
  #
  # source://shrine//lib/shrine/uploaded_file.rb#233
  def hash; end

  # The location where the file was uploaded to the storage.
  #
  # source://shrine//lib/shrine/uploaded_file.rb#26
  def id; end

  # Returns simplified inspect output.
  #
  # source://shrine//lib/shrine/uploaded_file.rb#253
  def inspect; end

  # A hash of file metadata that was extracted during upload.
  #
  # source://shrine//lib/shrine/uploaded_file.rb#32
  def metadata; end

  # The MIME type of the uploaded file.
  #
  # source://shrine//lib/shrine/uploaded_file.rb#65
  def mime_type; end

  # Calls `#open` on the storage to open the uploaded file for reading.
  # Most storages will return a lazy IO object which dynamically
  # retrieves file content from the storage as the object is being read.
  #
  # If a block is given, the opened IO object is yielded to the block,
  # and at the end of the block it's automatically closed. In this case
  # the return value of the method is the block return value.
  #
  # If no block is given, the opened IO object is returned.
  #
  #     uploaded_file.open #=> IO object returned by the storage
  #     uploaded_file.read #=> "..."
  #     uploaded_file.close
  #
  #     # or
  #
  #     uploaded_file.open { |io| io.read } # the IO is automatically closed
  #
  # source://shrine//lib/shrine/uploaded_file.rb#92
  def open(**options); end

  # Returns whether the file has already been opened.
  #
  # @return [Boolean]
  #
  # source://shrine//lib/shrine/uploaded_file.rb#176
  def opened?; end

  # The filename that was extracted from the uploaded file.
  #
  # source://shrine//lib/shrine/uploaded_file.rb#46
  def original_filename; end

  # Part of complying to the IO interface. It delegates to the internally
  # opened IO object.
  #
  # source://shrine//lib/shrine/uploaded_file.rb#153
  def read(*args); end

  # Uploads a new file to this file's location and returns it.
  #
  # source://shrine//lib/shrine/uploaded_file.rb#192
  def replace(io, **options); end

  # Part of complying to the IO interface. It delegates to the internally
  # opened IO object.
  #
  # source://shrine//lib/shrine/uploaded_file.rb#165
  def rewind; end

  # Returns the Shrine class that this file's class is namespaced under.
  #
  # source://shrine//lib/shrine/uploaded_file.rb#248
  def shrine_class; end

  # The filesize of the uploaded file.
  #
  # source://shrine//lib/shrine/uploaded_file.rb#60
  def size; end

  # Returns the storage that this file was uploaded to.
  #
  # source://shrine//lib/shrine/uploaded_file.rb#243
  def storage; end

  # The identifier of the storage the file is uploaded to.
  #
  # source://shrine//lib/shrine/uploaded_file.rb#29
  def storage_key; end

  # Streams uploaded file content into the specified destination. The
  # destination object is given directly to `IO.copy_stream`, so it can
  # be either a path on disk or an object that responds to `#write`.
  #
  # If the uploaded file is already opened, it will be simply rewinded
  # after streaming finishes. Otherwise the uploaded file is opened and
  # then closed after streaming.
  #
  #     uploaded_file.stream(StringIO.new)
  #     # or
  #     uploaded_file.stream("/path/to/destination")
  #
  # source://shrine//lib/shrine/uploaded_file.rb#142
  def stream(destination, **options); end

  # Returns an opened IO object for the uploaded file.
  #
  # source://shrine//lib/shrine/uploaded_file.rb#203
  def to_io; end

  # Returns the data hash in the JSON format. Suitable for storing in a
  # database column or passing to a background job.
  #
  # source://shrine//lib/shrine/uploaded_file.rb#209
  def to_json(*args); end

  # Returns an uploader object for the corresponding storage.
  #
  # source://shrine//lib/shrine/uploaded_file.rb#238
  def uploader; end

  # Calls `#url` on the storage, forwarding any given URL options.
  #
  # source://shrine//lib/shrine/uploaded_file.rb#181
  def url(**options); end

  private

  # source://shrine//lib/shrine/uploaded_file.rb#265
  def _open(**options); end

  # Returns an opened IO object for the uploaded file by calling `#open`
  # on the storage.
  #
  # source://shrine//lib/shrine/uploaded_file.rb#261
  def io; end
end

# source://shrine//lib/shrine/version.rb#8
module Shrine::VERSION; end

# source://shrine//lib/shrine/version.rb#9
Shrine::VERSION::MAJOR = T.let(T.unsafe(nil), Integer)

# source://shrine//lib/shrine/version.rb#10
Shrine::VERSION::MINOR = T.let(T.unsafe(nil), Integer)

# source://shrine//lib/shrine/version.rb#12
Shrine::VERSION::PRE = T.let(T.unsafe(nil), T.untyped)

# source://shrine//lib/shrine/version.rb#14
Shrine::VERSION::STRING = T.let(T.unsafe(nil), String)

# source://shrine//lib/shrine/version.rb#11
Shrine::VERSION::TINY = T.let(T.unsafe(nil), Integer)
