# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `neo4j-ruby-driver` gem.
# Please instead update this file by running `bin/tapioca gem neo4j-ruby-driver`.


# source://neo4j-ruby-driver//lib/neo4j-ruby-driver_loader.rb#16
module Neo4j; end

# source://neo4j-ruby-driver//lib/neo4j-ruby-driver_loader.rb#17
module Neo4j::Driver; end

# source://neo4j-ruby-driver//ruby/neo4j/driver/access_mode.rb#5
module Neo4j::Driver::AccessMode; end

# source://neo4j-ruby-driver//ruby/neo4j/driver/access_mode.rb#7
Neo4j::Driver::AccessMode::READ = T.let(T.unsafe(nil), Symbol)

# source://neo4j-ruby-driver//ruby/neo4j/driver/access_mode.rb#6
Neo4j::Driver::AccessMode::WRITE = T.let(T.unsafe(nil), Symbol)

# source://neo4j-ruby-driver//ruby/neo4j/driver/auth_tokens.rb#5
class Neo4j::Driver::AuthTokens
  class << self
    # source://neo4j-ruby-driver//ruby/neo4j/driver/auth_tokens.rb#7
    def basic(username, password, realm = T.unsafe(nil)); end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/auth_tokens.rb#13
    def bearer(token); end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/auth_tokens.rb#23
    def custom(principal, credentials, realm, scheme, **parameters); end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/auth_tokens.rb#18
    def kerberos(base64_encoded_ticket); end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/auth_tokens.rb#28
    def none; end
  end
end

# source://neo4j-ruby-driver//lib/neo4j/driver/auto_closable.rb#5
module Neo4j::Driver::AutoClosable
  # source://neo4j-ruby-driver//lib/neo4j/driver/auto_closable.rb#6
  def auto_closable(*methods); end

  private

  # source://neo4j-ruby-driver//lib/neo4j/driver/auto_closable.rb#12
  def with_block_definer(methods); end
end

# To opt out of this mechanism for unrelated units of work, applications can use multiple sessions.
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/bookmark.rb#12
module Neo4j::Driver::Bookmark
  class << self
    # Reconstruct bookmark from \bookmarks string values.
    #
    # @param values values obtained from a previous bookmark.
    # @return A bookmark.
    #
    # source://neo4j-ruby-driver//ruby/neo4j/driver/bookmark.rb#16
    def from(*values); end
  end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/config.rb#5
class Neo4j::Driver::Config < ::Hash
  # @return [Config] a new instance of Config
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/config.rb#68
  def initialize(**config); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/config.rb#73
  def routing_settings; end

  private

  # source://neo4j-ruby-driver//ruby/neo4j/driver/config.rb#80
  def init_security_and_trust_config; end
end

# Console.logger = ::Logger.new(STDOUT, level: :debug)
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/config.rb#40
Neo4j::Driver::Config::DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://neo4j-ruby-driver//ruby/neo4j/driver/config.rb#6
class Neo4j::Driver::Config::TrustStrategy
  # Sample config:
  # {
  #   trust_strategy: {
  #     strategy: :trust_custom_certificates,
  #     cert_files: ['some_path', 'another_path'],
  #     revocation_strategy: :no_checks, # or :verify_if_present, :strict
  #     hostname_verification: true
  #   },
  #   encryption: true
  # }
  #
  # @return [TrustStrategy] a new instance of TrustStrategy
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/config.rb#23
  def initialize(**config); end

  # Returns the value of attribute cert_files.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/config.rb#11
  def cert_files; end

  # @return [Boolean]
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/config.rb#34
  def hostname_verification_enabled?; end

  # Returns the value of attribute revocation_strategy.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/config.rb#11
  def revocation_strategy; end

  # Returns the value of attribute strategy.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/config.rb#11
  def strategy; end

  class << self
    # source://neo4j-ruby-driver//ruby/neo4j/driver/config.rb#30
    def trust_all_certificates; end
  end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/config.rb#7
Neo4j::Driver::Config::TrustStrategy::TRUST_ALL_CERTIFICATES = T.let(T.unsafe(nil), Symbol)

# source://neo4j-ruby-driver//ruby/neo4j/driver/config.rb#8
Neo4j::Driver::Config::TrustStrategy::TRUST_CUSTOM_CA_SIGNED_CERTIFICATES = T.let(T.unsafe(nil), Symbol)

# source://neo4j-ruby-driver//ruby/neo4j/driver/config.rb#9
Neo4j::Driver::Config::TrustStrategy::TRUST_SYSTEM_CA_SIGNED_CERTIFICATES = T.let(T.unsafe(nil), Symbol)

# source://neo4j-ruby-driver//ruby/neo4j/driver.rb#0
module Neo4j::Driver::Exceptions; end

# @since 1.1
#
# source://neo4j-ruby-driver//lib/neo4j/driver/exceptions/authentication_exception.rb#11
class Neo4j::Driver::Exceptions::AuthenticationException < ::Neo4j::Driver::Exceptions::SecurityException; end

# The authorization info maintained on the server has expired. The client should reconnect.
# <p>
# Error code: Neo.ClientError.Security.AuthorizationExpired
#
# source://neo4j-ruby-driver//lib/neo4j/driver/exceptions/authorization_expired_exception.rb#9
class Neo4j::Driver::Exceptions::AuthorizationExpiredException < ::Neo4j::Driver::Exceptions::SecurityException; end

# source://neo4j-ruby-driver//lib/neo4j/driver/exceptions/authorization_expired_exception.rb#10
Neo4j::Driver::Exceptions::AuthorizationExpiredException::DESCRIPTION = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//lib/neo4j/driver/exceptions/certificate_exception.rb#6
class Neo4j::Driver::Exceptions::CertificateException; end

# A <em>ClientException</em> indicates that the client has carried out an operation incorrectly.
# The error code provided can be used to determine further detail for the problem.
#
# @since 1.0
#
# source://neo4j-ruby-driver//lib/neo4j/driver/exceptions/client_exception.rb#9
class Neo4j::Driver::Exceptions::ClientException < ::Neo4j::Driver::Exceptions::Neo4jException
  class << self
    # @raise [self]
    # @since 1.0
    #
    # source://neo4j-ruby-driver//lib/neo4j/driver/exceptions/client_exception.rb#11
    def unable_to_convert(object); end
  end
end

# Indicates that read timed out due to it taking longer than the server-supplied timeout value via the {@code connection.recv_timeout_seconds} configuration
# hint. The server might provide this value to clients to let them know when a given connection may be considered broken if client does not get any
# communication from the server within the specified timeout period. This results in the server being removed from the routing table.
#
# source://neo4j-ruby-driver//lib/neo4j/driver/exceptions/connection_read_timeout_exception.rb#9
class Neo4j::Driver::Exceptions::ConnectionReadTimeoutException < ::Neo4j::Driver::Exceptions::ServiceUnavailableException; end

# source://neo4j-ruby-driver//lib/neo4j/driver/exceptions/connection_read_timeout_exception.rb#10
Neo4j::Driver::Exceptions::ConnectionReadTimeoutException::INSTANCE = T.let(T.unsafe(nil), Neo4j::Driver::Exceptions::ConnectionReadTimeoutException)

# A <em>DatabaseException</em> indicates that there is a problem within the underlying database.
# The error code provided can be used to determine further detail for the problem.
#
# @since 1.0
#
# source://neo4j-ruby-driver//lib/neo4j/driver/exceptions/database_exception.rb#9
class Neo4j::Driver::Exceptions::DatabaseException < ::Neo4j::Driver::Exceptions::Neo4jException; end

# If you see this error in your logs, it is safe to ignore if your cluster is temporarily changing structure during that time.
#
# source://neo4j-ruby-driver//lib/neo4j/driver/exceptions/discovery_exception.rb#12
class Neo4j::Driver::Exceptions::DiscoveryException < ::Neo4j::Driver::Exceptions::Neo4jException; end

# This error indicate a fatal problem to obtain routing tables such as the routing table for a specified database does not exist.
# This exception should not be retried.
#
# @since 4.0
#
# source://neo4j-ruby-driver//lib/neo4j/driver/exceptions/fatal_discovery_exception.rb#9
class Neo4j::Driver::Exceptions::FatalDiscoveryException < ::Neo4j::Driver::Exceptions::ClientException; end

# source://neo4j-ruby-driver//lib/neo4j/driver/exceptions/illegal_state_exception.rb#6
class Neo4j::Driver::Exceptions::IllegalStateException < ::RuntimeError; end

# source://neo4j-ruby-driver//lib/neo4j/driver/exceptions/neo4j_exception.rb#6
class Neo4j::Driver::Exceptions::Neo4jException < ::RuntimeError
  # @return [Neo4jException] a new instance of Neo4jException
  #
  # source://neo4j-ruby-driver//lib/neo4j/driver/exceptions/neo4j_exception.rb#9
  def initialize(*args); end

  # source://neo4j-ruby-driver//lib/neo4j/driver/exceptions/neo4j_exception.rb#16
  def add_suppressed(exception); end

  # Returns the value of attribute code.
  #
  # source://neo4j-ruby-driver//lib/neo4j/driver/exceptions/neo4j_exception.rb#7
  def code; end

  # Returns the value of attribute suppressed.
  #
  # source://neo4j-ruby-driver//lib/neo4j/driver/exceptions/neo4j_exception.rb#7
  def suppressed; end
end

# source://neo4j-ruby-driver//lib/neo4j/driver/exceptions/no_such_record_exception.rb#6
class Neo4j::Driver::Exceptions::NoSuchRecordException < ::RuntimeError
  class << self
    # source://neo4j-ruby-driver//lib/neo4j/driver/exceptions/no_such_record_exception.rb#14
    def empty; end

    # source://neo4j-ruby-driver//lib/neo4j/driver/exceptions/no_such_record_exception.rb#22
    def no_more; end

    # source://neo4j-ruby-driver//lib/neo4j/driver/exceptions/no_such_record_exception.rb#26
    def no_peek_past; end

    # source://neo4j-ruby-driver//lib/neo4j/driver/exceptions/no_such_record_exception.rb#18
    def too_many; end
  end
end

# source://neo4j-ruby-driver//lib/neo4j/driver/exceptions/no_such_record_exception.rb#7
Neo4j::Driver::Exceptions::NoSuchRecordException::EMPTY = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//lib/neo4j/driver/exceptions/no_such_record_exception.rb#10
Neo4j::Driver::Exceptions::NoSuchRecordException::NO_MORE = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//lib/neo4j/driver/exceptions/no_such_record_exception.rb#11
Neo4j::Driver::Exceptions::NoSuchRecordException::NO_PEEK_PAST = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//lib/neo4j/driver/exceptions/no_such_record_exception.rb#8
Neo4j::Driver::Exceptions::NoSuchRecordException::TOO_MANY = T.let(T.unsafe(nil), String)

# A signal that the contract for client-server communication has broken down.
# The user should contact support and cannot resolve this his or herself.
#
# source://neo4j-ruby-driver//lib/neo4j/driver/exceptions/protocol_exception.rb#8
class Neo4j::Driver::Exceptions::ProtocolException < ::Neo4j::Driver::Exceptions::Neo4jException
  # @return [ProtocolException] a new instance of ProtocolException
  #
  # source://neo4j-ruby-driver//lib/neo4j/driver/exceptions/protocol_exception.rb#11
  def initialize(message, e = T.unsafe(nil)); end
end

# source://neo4j-ruby-driver//lib/neo4j/driver/exceptions/protocol_exception.rb#9
Neo4j::Driver::Exceptions::ProtocolException::CODE = T.let(T.unsafe(nil), String)

# A user is trying to access resources that are no longer valid due to
# the resources have already been consumed or
# the {@link QueryRunner} where the resources are created has already been closed.
#
# source://neo4j-ruby-driver//lib/neo4j/driver/exceptions/result_consumed_exception.rb#9
class Neo4j::Driver::Exceptions::ResultConsumedException < ::Neo4j::Driver::Exceptions::ClientException; end

# Failed to communicate with the server due to security errors.
# When this type of error happens, the security cause of the error should be fixed to ensure the safety of your data.
# Restart of server/driver/cluster might be required to recover from this error.
#
# @since 1.1
#
# source://neo4j-ruby-driver//lib/neo4j/driver/exceptions/security_exception.rb#10
class Neo4j::Driver::Exceptions::SecurityException < ::Neo4j::Driver::Exceptions::ClientException; end

# An <em>ServiceUnavailableException</em> indicates that the driver cannot communicate with the cluster.
#
# @since 1.1
#
# source://neo4j-ruby-driver//lib/neo4j/driver/exceptions/service_unavailable_exception.rb#8
class Neo4j::Driver::Exceptions::ServiceUnavailableException < ::Neo4j::Driver::Exceptions::Neo4jException; end

# A <em>SessionExpiredException</em> indicates that the session can no longer satisfy the criteria under which it
# was acquired, e.g. a server no longer accepts write requests. A new session needs to be acquired from the driver
# and all actions taken on the expired session must be replayed.
#
# @since 1.1
#
# source://neo4j-ruby-driver//lib/neo4j/driver/exceptions/session_expired_exception.rb#10
class Neo4j::Driver::Exceptions::SessionExpiredException < ::Neo4j::Driver::Exceptions::Neo4jException; end

# The provided token has expired.
# <p>
# The current driver instance is considered invalid. It should not be used anymore. The client must create a new driver instance with a valid token.
# <p>
# Error code: Neo.ClientError.Security.TokenExpired
#
# source://neo4j-ruby-driver//lib/neo4j/driver/exceptions/token_expired_exception.rb#11
class Neo4j::Driver::Exceptions::TokenExpiredException < ::Neo4j::Driver::Exceptions::SecurityException; end

# This exception indicates a user is nesting new transaction with an on-going transaction (unmanaged and/or auto-commit).
#
# source://neo4j-ruby-driver//lib/neo4j/driver/exceptions/transaction_nesting_exception.rb#7
class Neo4j::Driver::Exceptions::TransactionNestingException < ::Neo4j::Driver::Exceptions::ClientException; end

# A <em>TransientException</em> signals a temporary fault that may be worked around by retrying.
# The error code provided can be used to determine further detail for the problem.
#
# @since 1.0
#
# source://neo4j-ruby-driver//lib/neo4j/driver/exceptions/transient_exception.rb#9
class Neo4j::Driver::Exceptions::TransientException < ::Neo4j::Driver::Exceptions::Neo4jException; end

# Thrown if the remote server cannot be verified as Neo4j.
#
# source://neo4j-ruby-driver//lib/neo4j/driver/exceptions/untrusted_server_exception.rb#7
class Neo4j::Driver::Exceptions::UntrustedServerException < ::RuntimeError; end

# source://neo4j-ruby-driver//ruby/neo4j/driver.rb#0
module Neo4j::Driver::Exceptions::Value; end

# A <em>LossyCoercion</em> exception indicates that the conversion cannot be achieved without losing precision.
#
# @since 1.0
#
# source://neo4j-ruby-driver//lib/neo4j/driver/exceptions/value/lossy_coercion.rb#7
class Neo4j::Driver::Exceptions::Value::LossyCoercion < ::Neo4j::Driver::Exceptions::Value::ValueException
  # @return [LossyCoercion] a new instance of LossyCoercion
  # @since 1.0
  #
  # source://neo4j-ruby-driver//lib/neo4j/driver/exceptions/value/lossy_coercion.rb#8
  def initialize(source_type_name, destination_type_name); end
end

# A <em>NotMultiValued</em> exception indicates that the value does not consist of multiple values, a.k.a. not a map
# or array.
#
# @since 1.0
#
# source://neo4j-ruby-driver//lib/neo4j/driver/exceptions/value/not_multi_valued.rb#8
class Neo4j::Driver::Exceptions::Value::NotMultiValued < ::Neo4j::Driver::Exceptions::Value::ValueException; end

# A <em>Uncoercible</em> exception indicates that the conversion cannot be achieved.
#
# @since 1.0
#
# source://neo4j-ruby-driver//lib/neo4j/driver/exceptions/value/uncoercible.rb#7
class Neo4j::Driver::Exceptions::Value::Uncoercible < ::Neo4j::Driver::Exceptions::Value::ValueException
  # @return [Uncoercible] a new instance of Uncoercible
  # @since 1.0
  #
  # source://neo4j-ruby-driver//lib/neo4j/driver/exceptions/value/uncoercible.rb#8
  def initialize(source_type_name, destination_type_name); end
end

# An <em>Unsizable</em> exception indicates that the value does not have a size.
#
# @since 1.0
#
# source://neo4j-ruby-driver//lib/neo4j/driver/exceptions/value/unsizable.rb#7
class Neo4j::Driver::Exceptions::Value::Unsizable < ::Neo4j::Driver::Exceptions::Value::ValueException; end

# A <em>ValueException</em> indicates that the client has carried out an operation on values incorrectly.
#
# @since 1.0
#
# source://neo4j-ruby-driver//lib/neo4j/driver/exceptions/value/value_exception.rb#7
class Neo4j::Driver::Exceptions::Value::ValueException < ::Neo4j::Driver::Exceptions::ClientException; end

# source://neo4j-ruby-driver//ruby/neo4j/driver/graph_database.rb#4
class Neo4j::Driver::GraphDatabase
  class << self
    # source://neo4j-ruby-driver//lib/neo4j/driver/auto_closable.rb#15
    def driver(*args, **kwargs, &block); end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/graph_database.rb#13
    def internal_driver(uri, auth_token, config, factory); end

    # @raise [Exceptions::ServiceUnavailableException]
    #
    # source://neo4j-ruby-driver//lib/neo4j/driver/auto_closable.rb#15
    def routing_driver(*args, **kwargs, &block); end

    private

    # source://neo4j-ruby-driver//ruby/neo4j/driver/graph_database.rb#71
    def assert_routing_uris(uris); end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/graph_database.rb#49
    def bolt_version(version); end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/graph_database.rb#57
    def bolt_versions(*versions); end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/graph_database.rb#65
    def close_driver(driver, uri, log); end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/graph_database.rb#61
    def pad(arr, n); end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/graph_database.rb#53
    def ruby_version(bolt_version); end
  end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver.rb#0
module Neo4j::Driver::Internal; end

# source://neo4j-ruby-driver//ruby/neo4j/driver/config.rb#0
module Neo4j::Driver::Internal::Async; end

# source://neo4j-ruby-driver//ruby/neo4j/driver.rb#0
module Neo4j::Driver::Internal::Async::Connection; end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/bolt_protocol_util.rb#5
class Neo4j::Driver::Internal::Async::Connection::BoltProtocolUtil
  class << self
    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/bolt_protocol_util.rb#19
    def handshake_buf; end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/bolt_protocol_util.rb#23
    def handshake_string; end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/bolt_protocol_util.rb#35
    def write_chunk_header(buf, chunk_start_index, header_value); end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/bolt_protocol_util.rb#31
    def write_empty_chunk_header(buf); end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/bolt_protocol_util.rb#27
    def write_message_boundary(buf); end

    private

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/bolt_protocol_util.rb#41
    def create_handshake_string; end
  end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/bolt_protocol_util.rb#6
Neo4j::Driver::Internal::Async::Connection::BoltProtocolUtil::BOLT_MAGIC_PREAMBLE = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/bolt_protocol_util.rb#8
Neo4j::Driver::Internal::Async::Connection::BoltProtocolUtil::CHUNK_HEADER_SIZE_BYTES = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/bolt_protocol_util.rb#9
Neo4j::Driver::Internal::Async::Connection::BoltProtocolUtil::DEFAULT_MAX_OUTBOUND_CHUNK_SIZE_BYTES = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/bolt_protocol_util.rb#10
Neo4j::Driver::Internal::Async::Connection::BoltProtocolUtil::HANDSHAKE = T.let(T.unsafe(nil), Array)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/bolt_protocol_util.rb#16
Neo4j::Driver::Internal::Async::Connection::BoltProtocolUtil::HANDSHAKE_BUF = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/bolt_protocol_util.rb#46
Neo4j::Driver::Internal::Async::Connection::BoltProtocolUtil::HANDSHAKE_STRING = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/bolt_protocol_util.rb#7
Neo4j::Driver::Internal::Async::Connection::BoltProtocolUtil::NO_PROTOCOL_VERSION = T.let(T.unsafe(nil), Neo4j::Driver::Internal::Messaging::BoltProtocolVersion)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/bootstrap_factory.rb#5
class Neo4j::Driver::Internal::Async::Connection::BootstrapFactory
  class << self
    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/bootstrap_factory.rb#7
    def new_bootstrap(thread_count: T.unsafe(nil), event_loop_group: T.unsafe(nil)); end
  end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/channel_attributes.rb#5
class Neo4j::Driver::Internal::Async::Connection::ChannelAttributes < ::Hash
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/channel_attributes.rb#21
  def []=(key, value); end
end

# CONNECTION_ID = org.neo4j.driver.internal.shaded.io.netty.util.AttributeKey.new_instance('connectionId')
# POOL_ID = org.neo4j.driver.internal.shaded.io.netty.util.AttributeKey.new_instance('poolId')
# PROTOCOL_VERSION = org.neo4j.driver.internal.shaded.io.netty.util.AttributeKey.new_instance('protocolVersion')
# SERVER_AGENT = org.neo4j.driver.internal.shaded.io.netty.util.AttributeKey.new_instance('serverAgent')
# ADDRESS = org.neo4j.driver.internal.shaded.io.netty.util.AttributeKey.new_instance('serverAddress')
# SERVER_VERSION = org.neo4j.driver.internal.shaded.io.netty.util.AttributeKey.new_instance('serverVersion')
# CREATION_TIMESTAMP = org.neo4j.driver.internal.shaded.io.netty.util.AttributeKey.new_instance('creationTimestamp')
# LAST_USED_TIMESTAMP = org.neo4j.driver.internal.shaded.io.netty.util.AttributeKey.new_instance('lastUsedTimestamp')
# MESSAGE_DISPATCHER = org.neo4j.driver.internal.shaded.io.netty.util.AttributeKey.new_instance('messageDispatcher')
# TERMINATION_REASON = org.neo4j.driver.internal.shaded.io.netty.util.AttributeKey.new_instance('terminationReason')
# AUTHORIZATION_STATE_LISTENER = org.neo4j.driver.internal.shaded.io.netty.util.AttributeKey.new_instance('authorizationStateListener')
# CONNECTION_READ_TIMEOUT = org.neo4j.driver.internal.shaded.io.netty.util.AttributeKey.new_instance('connectionReadTimeout')
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/channel_attributes.rb#19
Neo4j::Driver::Internal::Async::Connection::ChannelAttributes::UPDATABLE_KEYS = T.let(T.unsafe(nil), Array)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/channel_connected_listener.rb#5
class Neo4j::Driver::Internal::Async::Connection::ChannelConnectedListener < ::Struct
  # include org.neo4j.driver.internal.shaded.io.netty.channel.ChannelFutureListener
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/channel_connected_listener.rb#7
  def operationComplete(future); end

  class << self
    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/channel_connected_listener.rb#23
    def database_unavailable_error(address, cause); end
  end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/channel_connector_impl.rb#5
class Neo4j::Driver::Internal::Async::Connection::ChannelConnectorImpl
  # @return [ChannelConnectorImpl] a new instance of ChannelConnectorImpl
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/channel_connector_impl.rb#6
  def initialize(connection_settings, security_plan, logger, clock, routing_context, pipeline_builder = T.unsafe(nil), &domain_name_resolver); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/channel_connector_impl.rb#18
  def connect(address); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/channel_connector_impl.rb#37
  def initialize_channel(channel, protocol); end

  private

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/channel_connector_impl.rb#43
  def bracketless(host); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/channel_connector_impl.rb#47
  def install_channel_connected_listeners(address, channel_connected, handshake_completed); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/channel_connector_impl.rb#58
  def install_handshake_completed_listeners(handshake_completed, connection_initialized); end

  class << self
    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/channel_connector_impl.rb#71
    def require_valid_auth_token(token); end
  end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/channel_pipeline_builder_impl.rb#5
class Neo4j::Driver::Internal::Async::Connection::ChannelPipelineBuilderImpl
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/channel_pipeline_builder_impl.rb#6
  def build(message_format, pipeline, logger); end
end

# This is a connection used by {@link DirectConnectionProvider} to connect to a remote database.
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/direct_connection.rb#6
class Neo4j::Driver::Internal::Async::Connection::DirectConnection < ::Struct
  # Returns the value of attribute delegate
  #
  # @return [Object] the current value of delegate
  def connection; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/direct_connection.rb#7
  def disable_auto_read(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/direct_connection.rb#7
  def enable_auto_read(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/direct_connection.rb#7
  def flush(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/direct_connection.rb#7
  def open?(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/direct_connection.rb#7
  def protocol(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/direct_connection.rb#7
  def release(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/direct_connection.rb#7
  def reset(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/direct_connection.rb#7
  def server_address(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/direct_connection.rb#7
  def server_agent(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/direct_connection.rb#7
  def server_version(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/direct_connection.rb#7
  def terminate_and_release(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/direct_connection.rb#11
  def write(message1, handler1, message2 = T.unsafe(nil), handler2 = T.unsafe(nil)); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/direct_connection.rb#19
  def write_and_flush(message1, handler1, message2 = T.unsafe(nil), handler2 = T.unsafe(nil)); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/event_loop_group_factory.rb#5
class Neo4j::Driver::Internal::Async::Connection::EventLoopGroupFactory
  class << self
    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/event_loop_group_factory.rb#34
    def assert_not_in_event_loop_thread; end

    # {@link #newEventLoopGroup(int)}.
    #
    # @return class of the channel, which should be consistent with {@link EventLoopGroup}s returned by
    #
    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/event_loop_group_factory.rb#15
    def channel_class; end

    # @param thread the thread to check.
    # @return [@code true] when given thread belongs to the event loop, {@code false} otherwise.
    #
    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/event_loop_group_factory.rb#44
    def event_loop_thread?(thread); end

    # @param threadCount amount of IO threads for the new group.
    # @return new group consistent with channel class returned by {@link #channelClass()}.
    #
    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/event_loop_group_factory.rb#24
    def new_event_loop_group(thread_count); end
  end
end

# Same as {@link NioEventLoopGroup} but uses a different {@link ThreadFactory} that produces threads of
# {@link DriverThread} class. Such threads can be recognized by {@link #assertNotInEventLoopThread()}.
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/event_loop_group_factory.rb#53
class Neo4j::Driver::Internal::Async::Connection::EventLoopGroupFactory::DriverEventLoopGroup
  # < org.neo4j.driver.internal.shaded.io.netty.channel.nio.NioEventLoopGroup
  #
  # @return [DriverEventLoopGroup] a new instance of DriverEventLoopGroup
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/event_loop_group_factory.rb#54
  def initialize(n_threads = T.unsafe(nil)); end

  protected

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/event_loop_group_factory.rb#59
  def new_default_thread_factory; end
end

# < org.neo4j.driver.internal.shaded.io.netty.util.concurrent.FastThreadLocalThread
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/event_loop_group_factory.rb#77
class Neo4j::Driver::Internal::Async::Connection::EventLoopGroupFactory::DriverThread; end

# Same as {@link DefaultThreadFactory} created by {@link NioEventLoopGroup} by default, except produces threads of
# {@link DriverThread} class. Such threads can be recognized by {@link #assertNotInEventLoopThread()}.
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/event_loop_group_factory.rb#67
class Neo4j::Driver::Internal::Async::Connection::EventLoopGroupFactory::DriverThreadFactory
  # < org.neo4j.driver.internal.shaded.io.netty.util.concurrent.DefaultThreadFactory
  #
  # @return [DriverThreadFactory] a new instance of DriverThreadFactory
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/event_loop_group_factory.rb#68
  def initialize; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/event_loop_group_factory.rb#72
  def new_thread(r, name); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/event_loop_group_factory.rb#8
Neo4j::Driver::Internal::Async::Connection::EventLoopGroupFactory::THREAD_IS_DAEMON = T.let(T.unsafe(nil), TrueClass)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/event_loop_group_factory.rb#6
Neo4j::Driver::Internal::Async::Connection::EventLoopGroupFactory::THREAD_NAME_PREFIX = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/event_loop_group_factory.rb#7
Neo4j::Driver::Internal::Async::Connection::EventLoopGroupFactory::THREAD_PRIORITY = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/handshake_completed_listener.rb#5
class Neo4j::Driver::Internal::Async::Connection::HandshakeCompletedListener
  # @return [HandshakeCompletedListener] a new instance of HandshakeCompletedListener
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/handshake_completed_listener.rb#8
  def initialize(user_agent, auth_token, routing_context, connection_initialized_promise); end

  # Returns the value of attribute auth_token.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/handshake_completed_listener.rb#6
  def auth_token; end

  # Returns the value of attribute connection_initialized_promise.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/handshake_completed_listener.rb#6
  def connection_initialized_promise; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/handshake_completed_listener.rb#15
  def operation_complete(future); end

  # Returns the value of attribute routing_context.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/handshake_completed_listener.rb#6
  def routing_context; end

  # Returns the value of attribute user_agent.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/handshake_completed_listener.rb#6
  def user_agent; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/handshake_handler.rb#5
class Neo4j::Driver::Internal::Async::Connection::HandshakeHandler
  # @return [HandshakeHandler] a new instance of HandshakeHandler
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/handshake_handler.rb#6
  def initialize(logger); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/handshake_handler.rb#21
  def channel_inactive(ctx); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/handshake_handler.rb#41
  def decode(connection); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/handshake_handler.rb#31
  def exception_caught(ctx, error); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/handshake_handler.rb#11
  def handler_added(ctx); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/handshake_handler.rb#16
  def handler_removed0(ctx); end

  private

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/handshake_handler.rb#79
  def fail(ctx, error); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/handshake_handler.rb#69
  def handle_unknown_suggested_protocol_version(version, ctx); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/handshake_handler.rb#56
  def protocol_for_version(version); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/handshake_handler.rb#62
  def protocol_selected(version, protocol, connection); end

  class << self
    # @raise [Neo4j::Driver::Exception::ClientException]
    #
    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/handshake_handler.rb#88
    def http_endpoint_error; end

    # @raise [Neo4j::Driver::Exception::ClientException]
    #
    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/handshake_handler.rb#92
    def protocol_no_supported_by_driver_error(suggested_protocol_version); end

    # @raise [Neo4j::Driver::Exception::ClientException]
    #
    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/handshake_handler.rb#84
    def protocol_no_supported_by_server_error; end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/handshake_handler.rb#96
    def transform_error(error); end
  end
end

# < org.neo4j.driver.internal.shaded.io.netty.channel.ChannelInitializer
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/netty_channel_initializer.rb#5
class Neo4j::Driver::Internal::Async::Connection::NettyChannelInitializer
  # @return [NettyChannelInitializer] a new instance of NettyChannelInitializer
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/netty_channel_initializer.rb#6
  def initialize(address, security_plan, connect_timeout_millis, clock, logger); end

  protected

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/netty_channel_initializer.rb#17
  def initChannel(channel); end

  private

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/netty_channel_initializer.rb#35
  def create_ssl_engine; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/netty_channel_initializer.rb#28
  def create_ssl_handler; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/netty_channel_initializer.rb#48
  def update_channel_attributes(channel); end
end

# < org.neo4j.driver.internal.shaded.io.netty.resolver.InetNameResolver
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/netty_domain_name_resolver.rb#5
class Neo4j::Driver::Internal::Async::Connection::NettyDomainNameResolver
  # @return [NettyDomainNameResolver] a new instance of NettyDomainNameResolver
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/netty_domain_name_resolver.rb#6
  def initialize(executor, domain_name_resolver); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/netty_domain_name_resolver.rb#11
  def doResolve(inet_host, promise); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/netty_domain_name_resolver.rb#17
  def doResolveAll(inet_host, promise); end
end

# < org.neo4j.driver.internal.shaded.io.netty.resolver.AddressResolverGroup
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/netty_domain_name_resolver_group.rb#5
class Neo4j::Driver::Internal::Async::Connection::NettyDomainNameResolverGroup
  # @return [NettyDomainNameResolverGroup] a new instance of NettyDomainNameResolverGroup
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/netty_domain_name_resolver_group.rb#8
  def initialize(&domain_name_resolver); end

  # Returns the value of attribute domain_name_resolver.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/netty_domain_name_resolver_group.rb#6
  def domain_name_resolver; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/netty_domain_name_resolver_group.rb#12
  def newResolver(executor); end
end

# A connection used by the routing driver.
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/routing_connection.rb#6
class Neo4j::Driver::Internal::Async::Connection::RoutingConnection < ::Struct
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/routing_connection.rb#7
  def disable_auto_read(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/routing_connection.rb#7
  def enable_auto_read(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/routing_connection.rb#7
  def flush(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute access_mode
  #
  # @return [Object] the current value of access_mode
  def mode; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/routing_connection.rb#7
  def open?(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/routing_connection.rb#7
  def protocol(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/routing_connection.rb#7
  def release(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/routing_connection.rb#7
  def reset(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/routing_connection.rb#7
  def server_address(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/routing_connection.rb#7
  def server_agent(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/routing_connection.rb#7
  def server_version(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/routing_connection.rb#7
  def terminate_and_release(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/routing_connection.rb#11
  def write(message1, handler1, message2 = T.unsafe(nil), handler2 = T.unsafe(nil)); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/routing_connection.rb#19
  def write_and_flush(message1, handler1, message2 = T.unsafe(nil), handler2 = T.unsafe(nil)); end

  private

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/routing_connection.rb#29
  def new_routing_response_handler(handler); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/stream.rb#5
class Neo4j::Driver::Internal::Async::Connection::Stream < ::Async::IO::Stream
  include ::Neo4j::Driver::Internal::Packstream::PackInput
  include ::Neo4j::Driver::Internal::Packstream::PackOutput
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection/stream_reader.rb#5
class Neo4j::Driver::Internal::Async::Connection::StreamReader
  include ::Neo4j::Driver::Internal::Async::Inbound::ChunkDecoder
  include ::Neo4j::Driver::Internal::Packstream::PackInput
  include ::Neo4j::Driver::Internal::Packstream::PackStream::Common
  include ::Neo4j::Driver::Internal::Packstream::PackStream::Unpacker
  include ::Neo4j::Driver::Internal::Messaging::Common::CommonValue
  include ::Neo4j::Driver::Internal::Messaging::Common::CommonValueUnpacker
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection_context.rb#4
module Neo4j::Driver::Internal::Async::ConnectionContext; end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/connection_context.rb#5
Neo4j::Driver::Internal::Async::ConnectionContext::PENDING_DATABASE_NAME_EXCEPTION_SUPPLIER = T.let(T.unsafe(nil), Proc)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/immutable_connection_context.rb#4
class Neo4j::Driver::Internal::Async::ImmutableConnectionContext
  # @return [ImmutableConnectionContext] a new instance of ImmutableConnectionContext
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/immutable_connection_context.rb#7
  def initialize(database_name, bookmark, mode); end

  # Returns the value of attribute database_name.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/immutable_connection_context.rb#5
  def database_name; end

  # Returns the value of attribute impersonated_user.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/immutable_connection_context.rb#5
  def impersonated_user; end

  # Returns the value of attribute mode.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/immutable_connection_context.rb#5
  def mode; end

  # Returns the value of attribute rediscovery_bookmark.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/immutable_connection_context.rb#5
  def rediscovery_bookmark; end

  class << self
    # A simple context is used to test connectivity with a remote server/cluster. As long as there is a read only service, the connection shall be established
    # successfully. Depending on whether multidb is supported or not, this method returns different context for routing table discovery.
    #
    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/immutable_connection_context.rb#18
    def simple(supports_multi_db); end
  end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/immutable_connection_context.rb#14
Neo4j::Driver::Internal::Async::ImmutableConnectionContext::MULTI_DB_CONTEXT = T.let(T.unsafe(nil), Neo4j::Driver::Internal::Async::ImmutableConnectionContext)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/immutable_connection_context.rb#13
Neo4j::Driver::Internal::Async::ImmutableConnectionContext::SINGLE_DB_CONTEXT = T.let(T.unsafe(nil), Neo4j::Driver::Internal::Async::ImmutableConnectionContext)

# source://neo4j-ruby-driver//ruby/neo4j/driver.rb#0
module Neo4j::Driver::Internal::Async::Inbound; end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/byte_buf_input.rb#5
class Neo4j::Driver::Internal::Async::Inbound::ByteBufInput
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/byte_buf_input.rb#17
  def peek_byte; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/byte_buf_input.rb#6
  def read_byte(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/byte_buf_input.rb#6
  def read_bytes(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/byte_buf_input.rb#6
  def read_double(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/byte_buf_input.rb#6
  def read_int(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/byte_buf_input.rb#6
  def read_long(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/byte_buf_input.rb#6
  def read_short(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/byte_buf_input.rb#8
  def start(new_buf); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/byte_buf_input.rb#13
  def stop; end

  private

  # @raise [Neo4j::Driver::Exceptions::IllegalStateException]
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/byte_buf_input.rb#23
  def assert_not_started; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/channel_error_handler.rb#5
class Neo4j::Driver::Internal::Async::Inbound::ChannelErrorHandler
  # @return [ChannelErrorHandler] a new instance of ChannelErrorHandler
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/channel_error_handler.rb#6
  def initialize(logger); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/channel_error_handler.rb#21
  def channel_inactive(ctx); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/channel_error_handler.rb#38
  def exception_caught(ctx, error); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/channel_error_handler.rb#10
  def handler_added(ctx); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/channel_error_handler.rb#16
  def handler_removed(ctx); end

  private

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/channel_error_handler.rb#56
  def fail(error); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/channel_error_handler.rb#50
  def log_unexpected_error_warning(error); end

  class << self
    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/channel_error_handler.rb#62
    def transform_error(error); end
  end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/chunk_decoder.rb#5
module Neo4j::Driver::Internal::Async::Inbound::ChunkDecoder
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/chunk_decoder.rb#6
  def initialize(input); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/chunk_decoder.rb#28
  def ensure_termination; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/chunk_decoder.rb#11
  def read_exactly(size, buffer = T.unsafe(nil)); end

  private

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/chunk_decoder.rb#34
  def read_length_field; end
end

# Handler needed to limit amount of time connection performs TLS and Bolt handshakes.
# It should only be used when connection is established and removed from the pipeline afterwards.
# Otherwise it will make long running queries fail.
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/connect_timeout_handler.rb#8
class Neo4j::Driver::Internal::Async::Inbound::ConnectTimeoutHandler
  # < org.neo4j.driver.internal.shaded.io.netty.handler.timeout.ReadTimeoutHandler
  #
  # @return [ConnectTimeoutHandler] a new instance of ConnectTimeoutHandler
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/connect_timeout_handler.rb#9
  def initialize(timeout_millis); end

  protected

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/connect_timeout_handler.rb#16
  def readTimedOut(ctx); end

  private

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/connect_timeout_handler.rb#25
  def unable_to_connect_error; end
end

# < org.neo4j.driver.internal.shaded.io.netty.handler.timeout.ReadTimeoutHandler
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/connection_read_timeout_handler.rb#5
class Neo4j::Driver::Internal::Async::Inbound::ConnectionReadTimeoutHandler
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/connection_read_timeout_handler.rb#6
  def read_timeout(ctx); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/inbound_message_dispatcher.rb#5
class Neo4j::Driver::Internal::Async::Inbound::InboundMessageDispatcher
  # @return [InboundMessageDispatcher] a new instance of InboundMessageDispatcher
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/inbound_message_dispatcher.rb#8
  def initialize(channel, logger); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/inbound_message_dispatcher.rb#118
  def clear_current_error; end

  # Returns the value of attribute current_error.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/inbound_message_dispatcher.rb#6
  def current_error; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/inbound_message_dispatcher.rb#15
  def enqueue(handler); end

  # Returns the value of attribute fatal_error_occurred.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/inbound_message_dispatcher.rb#6
  def fatal_error_occurred; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/inbound_message_dispatcher.rb#99
  def handle_channel_error(error); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/inbound_message_dispatcher.rb#89
  def handle_channel_inactive(cause); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/inbound_message_dispatcher.rb#51
  def handle_failure_message(code:, message:); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/inbound_message_dispatcher.rb#75
  def handle_ignored_message; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/inbound_message_dispatcher.rb#42
  def handle_record_message(fields); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/inbound_message_dispatcher.rb#35
  def handle_success_message(meta); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/inbound_message_dispatcher.rb#122
  def prepare_to_close_channel; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/inbound_message_dispatcher.rb#31
  def queued_handlers_count; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/inbound_message_dispatcher.rb#126
  def remove_handler; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/inbound_message_dispatcher.rb#24
  def set_before_last_handler_hook(before_last_handler_hook); end

  private

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/inbound_message_dispatcher.rb#159
  def invoke_before_last_handler_hook(message_type); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/inbound_message_dispatcher.rb#145
  def update_auto_read_managing_handler(new_handler); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/inbound_message_dispatcher.rb#139
  def update_auto_read_managing_handler_if_needed(handler); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/inbound_message_dispatcher.rb#163
module Neo4j::Driver::Internal::Async::Inbound::InboundMessageDispatcher::HandlerHook; end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/inbound_message_dispatcher.rb#165
Neo4j::Driver::Internal::Async::Inbound::InboundMessageDispatcher::HandlerHook::FAILURE = T.let(T.unsafe(nil), Symbol)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/inbound_message_dispatcher.rb#164
Neo4j::Driver::Internal::Async::Inbound::InboundMessageDispatcher::HandlerHook::SUCCESS = T.let(T.unsafe(nil), Symbol)

# < org.neo4j.driver.internal.shaded.io.netty.channel.SimpleChannelInboundHandler
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/inbound_message_handler.rb#5
class Neo4j::Driver::Internal::Async::Inbound::InboundMessageHandler
  # @return [InboundMessageHandler] a new instance of InboundMessageHandler
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/inbound_message_handler.rb#6
  def initialize(message_format, logger); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/inbound_message_handler.rb#22
  def channel_read0(_ctx, msg); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/inbound_message_handler.rb#12
  def handler_added(ctx); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/inbound_message_handler.rb#17
  def handler_removed(_ctx); end
end

# <  org.neo4j.driver.internal.shaded.io.netty.handler.codec.ByteToMessageDecoder
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/message_decoder.rb#5
class Neo4j::Driver::Internal::Async::Inbound::MessageDecoder
  # @return [MessageDecoder] a new instance of MessageDecoder
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/message_decoder.rb#15
  def initialize; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/message_decoder.rb#19
  def channel_read(ctx, msg); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/message_decoder.rb#30
  def decode(ctx, inward, out); end

  class << self
    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/message_decoder.rb#7
    def determine_default_cumulator; end
  end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/inbound/message_decoder.rb#13
Neo4j::Driver::Internal::Async::Inbound::MessageDecoder::DEFAULT_CUMULATOR = T.let(T.unsafe(nil), T.untyped)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/internal_async_session.rb#4
class Neo4j::Driver::Internal::Async::InternalAsyncSession
  # @return [InternalAsyncSession] a new instance of InternalAsyncSession
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/internal_async_session.rb#5
  def initialize(session); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/internal_async_session.rb#15
  def begin_transaction_async(**config); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/internal_async_session.rb#9
  def close_async(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/internal_async_session.rb#9
  def last_bookmark(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/internal_async_session.rb#19
  def read_transaction_async(**config, &work); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/internal_async_session.rb#11
  def run_async(query, parameters = T.unsafe(nil), config = T.unsafe(nil)); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/internal_async_session.rb#23
  def write_transaction_async(**config, &work); end

  private

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/internal_async_session.rb#76
  def close_tx_after_failed_transaction_work(tx, result_future, error); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/internal_async_session.rb#84
  def close_tx_after_succeeded_transaction_work(tx, result_future, result); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/internal_async_session.rb#47
  def execute_work(result_future, tx, &work); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/internal_async_session.rb#61
  def safe_execute_work(tx); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/internal_async_session.rb#29
  def transaction_async(mode, **config, &work); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/internal_async_transaction.rb#4
class Neo4j::Driver::Internal::Async::InternalAsyncTransaction
  # @return [InternalAsyncTransaction] a new instance of InternalAsyncTransaction
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/internal_async_transaction.rb#7
  def initialize(tx); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/internal_async_transaction.rb#5
  def commit_async(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/internal_async_transaction.rb#5
  def open?(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/internal_async_transaction.rb#5
  def rollback_async(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/internal_async_transaction.rb#5
  def run_async(*_arg0, **_arg1, &_arg2); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/leak_logging_network_session.rb#4
class Neo4j::Driver::Internal::Async::LeakLoggingNetworkSession < ::Neo4j::Driver::Internal::Async::NetworkSession
  # @return [LeakLoggingNetworkSession] a new instance of LeakLoggingNetworkSession
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/leak_logging_network_session.rb#5
  def initialize(connection_provider, retry_logic, database_name, mode, bookmark_holder, impersonated_user, fetch_size, logger); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/leak_logging_network_session.rb#10
  def finalize; end

  private

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/leak_logging_network_session.rb#28
  def capture_stack_trace; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/leak_logging_network_session.rb#17
  def log_leak_if_needed; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/network_connection.rb#4
class Neo4j::Driver::Internal::Async::NetworkConnection
  include ::Neo4j::Driver::Internal::Spi::Connection

  # @return [NetworkConnection] a new instance of NetworkConnection
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/network_connection.rb#10
  def initialize(channel, channel_pool, logger, &on_pool_shutdown); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/network_connection.rb#34
  def disable_auto_read; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/network_connection.rb#30
  def enable_auto_read; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/network_connection.rb#38
  def flush; end

  # @return [Boolean]
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/network_connection.rb#26
  def open?; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/network_connection.rb#6
  def protocol(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/network_connection.rb#65
  def release; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/network_connection.rb#58
  def reset; end

  # Returns the value of attribute server_address.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/network_connection.rb#8
  def server_address; end

  # Returns the value of attribute server_agent.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/network_connection.rb#8
  def server_agent; end

  # Returns the value of attribute server_version.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/network_connection.rb#8
  def server_version; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/network_connection.rb#75
  def terminate_and_release(reason); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/network_connection.rb#42
  def write(message1, handler1, message2 = T.unsafe(nil), handler2 = T.unsafe(nil)); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/network_connection.rb#50
  def write_and_flush(message1, handler1, message2 = T.unsafe(nil), handler2 = T.unsafe(nil)); end

  private

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/network_connection.rb#112
  def flush_in_event_loop; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/network_connection.rb#167
  def register_connection_read_timeout(channel); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/network_connection.rb#140
  def verify_open(handler1, handler2); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/network_connection.rb#119
  def write_message_in_event_loop(message, handler, flush); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/network_connection.rb#125
  def write_messages_in_event_loop(message1, handler1, message2, handler2, flush); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/network_connection.rb#86
  def write_reset_message_if_needed(reset_handler, is_session_reset); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/network_connection.rb#97
  def write_to_channel(message, flush = T.unsafe(nil)); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/network_connection.rb#186
class Neo4j::Driver::Internal::Async::NetworkConnection::Status; end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/network_connection.rb#187
Neo4j::Driver::Internal::Async::NetworkConnection::Status::OPEN = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/network_connection.rb#188
Neo4j::Driver::Internal::Async::NetworkConnection::Status::RELEASED = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/network_connection.rb#189
Neo4j::Driver::Internal::Async::NetworkConnection::Status::TERMINATED = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/network_session.rb#4
class Neo4j::Driver::Internal::Async::NetworkSession
  # @return [NetworkSession] a new instance of NetworkSession
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/network_session.rb#7
  def initialize(connection_provider, retry_logic, database_name, mode, bookmark_holder, impersonated_user, fetch_size, logger); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/network_session.rb#25
  def begin_transaction_async(mode = T.unsafe(nil), **config); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/network_session.rb#61
  def close_async; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/network_session.rb#53
  def connection_async; end

  # @return [Boolean]
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/network_session.rb#72
  def current_connection_open?; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/network_session.rb#45
  def last_bookmark; end

  # @return [Boolean]
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/network_session.rb#57
  def open?; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/network_session.rb#49
  def release_connection_async; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/network_session.rb#35
  def reset_async; end

  # Returns the value of attribute retry_logic.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/network_session.rb#5
  def retry_logic; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/network_session.rb#19
  def run_async(query, **config); end

  private

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/network_session.rb#87
  def acquire_connection(mode); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/network_session.rb#78
  def build_result_cursor_factory(query, config); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/network_session.rb#98
  def close_transaction_and_release_connection; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/network_session.rb#112
  def ensure_no_open_tx(error_message); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/network_session.rb#104
  def ensure_no_open_tx_before_running_query; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/network_session.rb#108
  def ensure_no_open_tx_before_starting_tx; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/network_session.rb#122
  def ensure_session_is_open; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/network_session.rb#118
  def existing_transaction_or_null; end
end

# The {@link NetworkSessionConnectionContext#mode} can be mutable for a session connection context
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/network_session.rb#129
class Neo4j::Driver::Internal::Async::NetworkSession::NetworkSessionConnectionContext
  # @return [NetworkSessionConnectionContext] a new instance of NetworkSessionConnectionContext
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/network_session.rb#136
  def initialize(database_name, bookmark, impersonated_user); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/network_session.rb#142
  def context_with_mode(mode); end

  # This bookmark is only used for rediscovery.
  # It has to be the initial bookmark given at the creation of the session.
  # As only that bookmark could carry extra system bookmarks
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/network_session.rb#133
  def database_name; end

  # This bookmark is only used for rediscovery.
  # It has to be the initial bookmark given at the creation of the session.
  # As only that bookmark could carry extra system bookmarks
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/network_session.rb#133
  def database_name=(_arg0); end

  # Returns the value of attribute impersonated_user.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/network_session.rb#134
  def impersonated_user; end

  # Returns the value of attribute mode.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/network_session.rb#134
  def mode; end

  # Returns the value of attribute rediscovery_bookmark.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/network_session.rb#134
  def rediscovery_bookmark; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver.rb#0
module Neo4j::Driver::Internal::Async::Outbound; end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/outbound/chunk_aware_byte_buf_output.rb#5
class Neo4j::Driver::Internal::Async::Outbound::ChunkAwareByteBufOutput
  include ::Neo4j::Driver::Internal::Packstream::PackStream::Common
  include ::Neo4j::Driver::Internal::Packstream::PackStream::Packer
  include ::Neo4j::Driver::Internal::Messaging::Common::CommonValue
  include ::Neo4j::Driver::Internal::Messaging::Common::CommonValuePacker

  # @return [ChunkAwareByteBufOutput] a new instance of ChunkAwareByteBufOutput
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/outbound/chunk_aware_byte_buf_output.rb#14
  def initialize(output, max_chunk_size: T.unsafe(nil)); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/outbound/chunk_aware_byte_buf_output.rb#20
  def start; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/outbound/chunk_aware_byte_buf_output.rb#77
  def stop; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/outbound/chunk_aware_byte_buf_output.rb#31
  def write(data); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/outbound/chunk_aware_byte_buf_output.rb#25
  def write_byte(value); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/outbound/chunk_aware_byte_buf_output.rb#77
  def write_chunk; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/outbound/chunk_aware_byte_buf_output.rb#67
  def write_double(value); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/outbound/chunk_aware_byte_buf_output.rb#55
  def write_int(value); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/outbound/chunk_aware_byte_buf_output.rb#61
  def write_long(value); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/outbound/chunk_aware_byte_buf_output.rb#73
  def write_message_boundary; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/outbound/chunk_aware_byte_buf_output.rb#49
  def write_short(value); end

  private

  # @raise [Neo4j::Driver::Exceptions::IllegalStateException]
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/outbound/chunk_aware_byte_buf_output.rb#95
  def assert_not_started; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/outbound/chunk_aware_byte_buf_output.rb#91
  def available_bytes_in_current_chunk; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/outbound/chunk_aware_byte_buf_output.rb#87
  def ensure_can_fit_in_current_chunk(number_of_bytes); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/outbound/chunk_aware_byte_buf_output.rb#99
  def verify_max_chunk_size(max_chunk_size); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/outbound/chunk_aware_byte_buf_output.rb#9
class Neo4j::Driver::Internal::Async::Outbound::ChunkAwareByteBufOutput::ChunkBuffer < ::Async::IO::Buffer
  include ::Neo4j::Driver::Internal::Packstream::PackOutput

  # source://async-io/1.43.2/lib/async/io/buffer.rb#17
  def write(string); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/outbound/outbound_message_handler.rb#5
class Neo4j::Driver::Internal::Async::Outbound::OutboundMessageHandler
  # @return [OutboundMessageHandler] a new instance of OutboundMessageHandler
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/outbound/outbound_message_handler.rb#8
  def initialize(output, message_format, logger); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/outbound/outbound_message_handler.rb#22
  def encode(msg); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/outbound/outbound_message_handler.rb#14
  def handler_added(ctx); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/outbound/outbound_message_handler.rb#18
  def handler_removed(ctx); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/outbound/outbound_message_handler.rb#6
Neo4j::Driver::Internal::Async::Outbound::OutboundMessageHandler::NAME = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//ruby/neo4j/driver/config.rb#0
module Neo4j::Driver::Internal::Async::Pool; end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/channel.rb#5
class Neo4j::Driver::Internal::Async::Pool::Channel
  # @return [Channel] a new instance of Channel
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/channel.rb#11
  def initialize(address, connector, logger); end

  # should be attr
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/channel.rb#8
  def attributes; end

  # Returns the value of attribute auto_read.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/channel.rb#9
  def auto_read; end

  # Sets the attribute auto_read
  #
  # @param value the value to set the attribute auto_read to.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/channel.rb#9
  def auto_read=(_arg0); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/channel.rb#26
  def close; end

  # Returns the value of attribute message_dispatcher.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/channel.rb#7
  def message_dispatcher; end

  # Sets the attribute message_dispatcher
  #
  # @param value the value to set the attribute message_dispatcher to.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/channel.rb#7
  def message_dispatcher=(_arg0); end

  # Returns the value of attribute message_format.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/channel.rb#7
  def message_format; end

  # Sets the attribute message_format
  #
  # @param value the value to set the attribute message_format to.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/channel.rb#7
  def message_format=(_arg0); end

  # Returns the value of attribute protocol.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/channel.rb#7
  def protocol; end

  # Sets the attribute protocol
  #
  # @param value the value to set the attribute protocol to.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/channel.rb#7
  def protocol=(_arg0); end

  # Returns the value of attribute stream.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/channel.rb#6
  def stream; end

  # Returns the value of attribute version.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/channel.rb#7
  def version; end

  # Sets the attribute version
  #
  # @param value the value to set the attribute version to.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/channel.rb#7
  def version=(_arg0); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/channel.rb#30
  def write(message); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/channel.rb#34
  def write_and_flush(message); end

  private

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/channel.rb#46
  def bracketless(host); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/channel.rb#42
  def connect_to_io_socket(connector, address); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/channel.rb#50
  def ensure_response_handling; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/channel_pool.rb#5
class Neo4j::Driver::Internal::Async::Pool::ChannelPool < ::ConnectionPool
  # @return [ChannelPool] a new instance of ChannelPool
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/channel_pool.rb#6
  def initialize(limit: T.unsafe(nil), acquisition_timeout: T.unsafe(nil), &block); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/channel_pool.rb#11
  def acquire(options = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/channel_pool.rb#24
  def busy?; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/channel_pool.rb#20
  def close; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/channel_pool.rb#15
  def release(resource); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/channel_tracker.rb#5
class Neo4j::Driver::Internal::Async::Pool::ChannelTracker
  # @return [ChannelTracker] a new instance of ChannelTracker
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/channel_tracker.rb#9
  def initialize(metrics_listener, logger, **options); end

  # Returns the value of attribute address_to_idle_channel_count.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/channel_tracker.rb#6
  def address_to_idle_channel_count; end

  # Returns the value of attribute address_to_in_use_channel_count.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/channel_tracker.rb#6
  def address_to_in_use_channel_count; end

  # Returns the value of attribute all_channels.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/channel_tracker.rb#6
  def all_channels; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/channel_tracker.rb#50
  def channel_closed(channel); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/channel_tracker.rb#27
  def channel_created(channel, creating_event = T.unsafe(nil)); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/channel_tracker.rb#40
  def channel_creating(pool_id); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/channel_tracker.rb#46
  def channel_failed_to_create(pool_id); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/channel_tracker.rb#17
  def channel_released(channel); end

  # Returns the value of attribute close_listener.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/channel_tracker.rb#6
  def close_listener; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/channel_tracker.rb#59
  def idle_channel_count(address); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/channel_tracker.rb#55
  def in_use_channel_count(address); end

  # Returns the value of attribute lock.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/channel_tracker.rb#6
  def lock; end

  # Returns the value of attribute log.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/channel_tracker.rb#6
  def log; end

  # Returns the value of attribute metrics_listener.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/channel_tracker.rb#6
  def metrics_listener; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/channel_tracker.rb#63
  def prepare_to_close_channels; end

  # Returns the value of attribute read.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/channel_tracker.rb#6
  def read; end

  # Returns the value of attribute write.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/channel_tracker.rb#6
  def write; end

  private

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/channel_tracker.rb#97
  def decrement_idle(channel); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/channel_tracker.rb#82
  def decrement_in_use(channel); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/channel_tracker.rb#114
  def do_in_write_lock(work); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/channel_tracker.rb#108
  def increment(channel, count_map); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/channel_tracker.rb#93
  def increment_idle(channel); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/channel_tracker.rb#78
  def increment_in_use(channel); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/channel_tracker.rb#123
  def retrieve_in_read_lock(work); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/connection_pool_impl.rb#5
class Neo4j::Driver::Internal::Async::Pool::ConnectionPoolImpl
  # @return [ConnectionPoolImpl] a new instance of ConnectionPoolImpl
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/connection_pool_impl.rb#6
  def initialize(connector, settings, logger); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/connection_pool_impl.rb#15
  def acquire(address); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/connection_pool_impl.rb#64
  def close; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/connection_pool_impl.rb#60
  def idle_connections(address); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/connection_pool_impl.rb#55
  def in_use_connections(address); end

  # @return [Boolean]
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/connection_pool_impl.rb#75
  def open?(address); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/connection_pool_impl.rb#49
  def remove(pool); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/connection_pool_impl.rb#31
  def retain_all(addresses_to_retain); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/connection_pool_impl.rb#79
  def to_string; end

  protected

  # for testing only
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/connection_pool_impl.rb#113
  def pool(address); end

  private

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/connection_pool_impl.rb#100
  def assert_not_closed(address = T.unsafe(nil), channel = T.unsafe(nil), pool = T.unsafe(nil)); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/connection_pool_impl.rb#145
  def close_all_pools; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/connection_pool_impl.rb#132
  def close_pool(pool); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/connection_pool_impl.rb#136
  def close_pool_in_background(address, pool); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/connection_pool_impl.rb#121
  def get_or_create_pool(address); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/connection_pool_impl.rb#117
  def new_pool(address); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/connection_pool_impl.rb#85
  def process_acquisition_error(pool, server_address, error); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/netty_channel_health_checker.rb#5
class Neo4j::Driver::Internal::Async::Pool::NettyChannelHealthChecker
  # @return [NettyChannelHealthChecker] a new instance of NettyChannelHealthChecker
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/netty_channel_health_checker.rb#8
  def initialize(pool_settings, clock, logger); end

  # Returns the value of attribute clock.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/netty_channel_health_checker.rb#6
  def clock; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/netty_channel_health_checker.rb#15
  def is_healthy(channel); end

  # Returns the value of attribute log.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/netty_channel_health_checker.rb#6
  def log; end

  # Returns the value of attribute logger.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/netty_channel_health_checker.rb#6
  def logger; end

  # Returns the value of attribute min_creation_timestamp_millis_opt.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/netty_channel_health_checker.rb#6
  def min_creation_timestamp_millis_opt; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/netty_channel_health_checker.rb#23
  def on_expired(e, channel); end

  # Returns the value of attribute pool_settings.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/netty_channel_health_checker.rb#6
  def pool_settings; end

  private

  # @return [Boolean]
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/netty_channel_health_checker.rb#60
  def has_been_idle_for_too_long?(channel); end

  # @return [Boolean]
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/netty_channel_health_checker.rb#34
  def is_too_old?(channel); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/netty_channel_health_checker.rb#77
  def ping(channel); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/netty_channel_pool.rb#5
class Neo4j::Driver::Internal::Async::Pool::NettyChannelPool
  # @return [NettyChannelPool] a new instance of NettyChannelPool
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/netty_channel_pool.rb#14
  def initialize(address, connector, bootstrap, handler, health_check, acquire_timeout_millis, max_connections); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/netty_channel_pool.rb#31
  def acquire; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/netty_channel_pool.rb#24
  def close; end

  # Returns the value of attribute id.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/netty_channel_pool.rb#12
  def id; end

  # @return [Boolean]
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/netty_channel_pool.rb#39
  def is_closed?; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/netty_channel_pool.rb#35
  def release(channel); end

  private

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/netty_channel_pool.rb#45
  def pool_id(server_address); end
end

# Unlimited amount of parties are allowed to request channels from the pool.
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/netty_channel_pool.rb#7
Neo4j::Driver::Internal::Async::Pool::NettyChannelPool::MAX_PENDING_ACQUIRES = T.let(T.unsafe(nil), T.untyped)

# Do not check channels when they are returned to the pool.
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/netty_channel_pool.rb#10
Neo4j::Driver::Internal::Async::Pool::NettyChannelPool::RELEASE_HEALTH_CHECK = T.let(T.unsafe(nil), FalseClass)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/network_connection_factory.rb#5
class Neo4j::Driver::Internal::Async::Pool::NetworkConnectionFactory
  # @return [NetworkConnectionFactory] a new instance of NetworkConnectionFactory
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/network_connection_factory.rb#8
  def initialize(clock, metrics_listener, logger); end

  # Returns the value of attribute clock.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/network_connection_factory.rb#6
  def clock; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/network_connection_factory.rb#14
  def create_connection(channel, pool); end

  # Returns the value of attribute logger.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/network_connection_factory.rb#6
  def logger; end

  # Returns the value of attribute metrics_listener.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/network_connection_factory.rb#6
  def metrics_listener; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/pool_settings.rb#5
class Neo4j::Driver::Internal::Async::Pool::PoolSettings
  # @return [PoolSettings] a new instance of PoolSettings
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/pool_settings.rb#15
  def initialize(max_connection_pool_size, connection_acquisition_timeout, max_connection_lifetime, idle_time_before_connection_test); end

  # Returns the value of attribute connection_acquisition_timeout.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/pool_settings.rb#6
  def connection_acquisition_timeout; end

  # Returns the value of attribute idle_time_before_connection_test.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/pool_settings.rb#6
  def idle_time_before_connection_test; end

  # @return [Boolean]
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/pool_settings.rb#23
  def idle_time_before_connection_test_enabled?; end

  # Returns the value of attribute max_connection_lifetime.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/pool_settings.rb#6
  def max_connection_lifetime; end

  # @return [Boolean]
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/pool_settings.rb#27
  def max_connection_lifetime_enabled?; end

  # Returns the value of attribute max_connection_pool_size.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/pool_settings.rb#6
  def max_connection_pool_size; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/pool_settings.rb#13
Neo4j::Driver::Internal::Async::Pool::PoolSettings::DEFAULT_CONNECTION_ACQUISITION_TIMEOUT = T.let(T.unsafe(nil), ActiveSupport::Duration)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/pool_settings.rb#11
Neo4j::Driver::Internal::Async::Pool::PoolSettings::DEFAULT_IDLE_TIME_BEFORE_CONNECTION_TEST = T.let(T.unsafe(nil), T.untyped)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/pool_settings.rb#12
Neo4j::Driver::Internal::Async::Pool::PoolSettings::DEFAULT_MAX_CONNECTION_LIFETIME = T.let(T.unsafe(nil), ActiveSupport::Duration)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/pool_settings.rb#10
Neo4j::Driver::Internal::Async::Pool::PoolSettings::DEFAULT_MAX_CONNECTION_POOL_SIZE = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/pool_settings.rb#9
Neo4j::Driver::Internal::Async::Pool::PoolSettings::NOT_CONFIGURED = T.let(T.unsafe(nil), T.untyped)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/timed_stack.rb#5
class Neo4j::Driver::Internal::Async::Pool::TimedStack < ::ConnectionPool::TimedStack
  # @return [Boolean]
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/pool/timed_stack.rb#6
  def any_resource_busy?; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/result_cursors_holder.rb#4
class Neo4j::Driver::Internal::Async::ResultCursorsHolder < ::Array
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/result_cursors_holder.rb#5
  def retrieve_not_consumed_error; end

  private

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/result_cursors_holder.rb#11
  def retrieve_all_failures; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/unmanaged_transaction.rb#4
class Neo4j::Driver::Internal::Async::UnmanagedTransaction
  # @return [UnmanagedTransaction] a new instance of UnmanagedTransaction
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/unmanaged_transaction.rb#28
  def initialize(connection, bookmark_holder, fetch_size, result_cursors = T.unsafe(nil)); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/unmanaged_transaction.rb#38
  def begin_async(initial_bookmark, config); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/unmanaged_transaction.rb#52
  def close_async(commit = T.unsafe(nil), complete_with_null_if_not_open = T.unsafe(nil)); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/unmanaged_transaction.rb#103
  def commit_async; end

  # Returns the value of attribute connection.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/unmanaged_transaction.rb#26
  def connection; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/unmanaged_transaction.rb#140
  def ensure_can_run_queries; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/unmanaged_transaction.rb#129
  def mark_terminated(cause); end

  # @return [Boolean]
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/unmanaged_transaction.rb#125
  def open?; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/unmanaged_transaction.rb#107
  def rollback_async; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/unmanaged_transaction.rb#111
  def run_async(query); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/unmanaged_transaction.rb#118
  def run_rx(query); end

  private

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/unmanaged_transaction.rb#156
  def add_suppressed_when_not_captured(current_cause, new_cause); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/unmanaged_transaction.rb#166
  def do_commit_async(cursor_failure); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/unmanaged_transaction.rb#182
  def do_rollback_async; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/unmanaged_transaction.rb#190
  def handle_commit_or_rollback(cursor_failure); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/unmanaged_transaction.rb#197
  def handle_transaction_completion(commit_attempt, throwable); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/unmanaged_transaction.rb#19
Neo4j::Driver::Internal::Async::UnmanagedTransaction::CANT_COMMIT_COMMITTED_MSG = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/unmanaged_transaction.rb#21
Neo4j::Driver::Internal::Async::UnmanagedTransaction::CANT_COMMIT_ROLLED_BACK_MSG = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/unmanaged_transaction.rb#23
Neo4j::Driver::Internal::Async::UnmanagedTransaction::CANT_COMMIT_ROLLING_BACK_MSG = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/unmanaged_transaction.rb#20
Neo4j::Driver::Internal::Async::UnmanagedTransaction::CANT_ROLLBACK_COMMITTED_MSG = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/unmanaged_transaction.rb#24
Neo4j::Driver::Internal::Async::UnmanagedTransaction::CANT_ROLLBACK_COMMITTING_MSG = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/unmanaged_transaction.rb#22
Neo4j::Driver::Internal::Async::UnmanagedTransaction::CANT_ROLLBACK_ROLLED_BACK_MSG = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/unmanaged_transaction.rb#25
Neo4j::Driver::Internal::Async::UnmanagedTransaction::OPEN_STATES = T.let(T.unsafe(nil), Array)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/unmanaged_transaction.rb#5
class Neo4j::Driver::Internal::Async::UnmanagedTransaction::State; end

# The transaction is running with no explicit success or failure marked
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/unmanaged_transaction.rb#7
Neo4j::Driver::Internal::Async::UnmanagedTransaction::State::ACTIVE = T.let(T.unsafe(nil), String)

# This transaction has successfully committed
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/unmanaged_transaction.rb#13
Neo4j::Driver::Internal::Async::UnmanagedTransaction::State::COMMITTED = T.let(T.unsafe(nil), String)

# This transaction has been rolled back
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/unmanaged_transaction.rb#16
Neo4j::Driver::Internal::Async::UnmanagedTransaction::State::ROLLED_BACK = T.let(T.unsafe(nil), String)

# This transaction has been terminated either because of explicit {@link Session#reset()} or because of a fatal connection error.
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/async/unmanaged_transaction.rb#10
Neo4j::Driver::Internal::Async::UnmanagedTransaction::State::TERMINATED = T.let(T.unsafe(nil), String)

# Holds a host and port pair that denotes a Bolt server address.
#
# source://neo4j-ruby-driver//lib/neo4j/driver/internal/bolt_server_address.rb#4
class Neo4j::Driver::Internal::BoltServerAddress
  # @return [BoltServerAddress] a new instance of BoltServerAddress
  #
  # source://neo4j-ruby-driver//lib/neo4j/driver/internal/bolt_server_address.rb#61
  def initialize(uri: T.unsafe(nil), host: T.unsafe(nil), port: T.unsafe(nil), connection_host: T.unsafe(nil)); end

  # source://neo4j-ruby-driver//lib/neo4j/driver/internal/bolt_server_address.rb#73
  def ==(other); end

  # source://neo4j-ruby-driver//lib/neo4j/driver/internal/bolt_server_address.rb#92
  def attributes; end

  # Returns the value of attribute connection_host.
  #
  # source://neo4j-ruby-driver//lib/neo4j/driver/internal/bolt_server_address.rb#5
  def connection_host; end

  # source://neo4j-ruby-driver//lib/neo4j/driver/internal/bolt_server_address.rb#73
  def eql?(other); end

  # source://neo4j-ruby-driver//lib/neo4j/driver/internal/bolt_server_address.rb#6
  def hash(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute host.
  #
  # source://neo4j-ruby-driver//lib/neo4j/driver/internal/bolt_server_address.rb#5
  def host; end

  # Returns the value of attribute port.
  #
  # source://neo4j-ruby-driver//lib/neo4j/driver/internal/bolt_server_address.rb#5
  def port; end

  # source://neo4j-ruby-driver//lib/neo4j/driver/internal/bolt_server_address.rb#79
  def to_s; end

  # @return stream of unicast addresses.
  #
  # source://neo4j-ruby-driver//lib/neo4j/driver/internal/bolt_server_address.rb#88
  def unicast_stream; end

  class << self
    # source://neo4j-ruby-driver//lib/neo4j/driver/internal/bolt_server_address.rb#69
    def from(address); end

    # source://neo4j-ruby-driver//lib/neo4j/driver/internal/bolt_server_address.rb#11
    def host_from(uri); end

    # source://neo4j-ruby-driver//lib/neo4j/driver/internal/bolt_server_address.rb#36
    def host_port_from(address); end

    # source://neo4j-ruby-driver//lib/neo4j/driver/internal/bolt_server_address.rb#50
    def invalid_address_format(address); end

    # source://neo4j-ruby-driver//lib/neo4j/driver/internal/bolt_server_address.rb#15
    def port_from(uri); end

    # @raise [ArgumentError]
    #
    # source://neo4j-ruby-driver//lib/neo4j/driver/internal/bolt_server_address.rb#54
    def require_valid_port(port); end

    # source://neo4j-ruby-driver//lib/neo4j/driver/internal/bolt_server_address.rb#19
    def uri_from(address); end
  end
end

# source://neo4j-ruby-driver//lib/neo4j/driver/internal/bolt_server_address.rb#8
Neo4j::Driver::Internal::BoltServerAddress::DEFAULT_PORT = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//lib/neo4j/driver/internal/bolt_server_address.rb#67
Neo4j::Driver::Internal::BoltServerAddress::LOCAL_DEFAULT = T.let(T.unsafe(nil), Neo4j::Driver::Internal::BoltServerAddress)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/bookmark_holder.rb#3
class Neo4j::Driver::Internal::BookmarkHolder; end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/bookmark_holder.rb#4
Neo4j::Driver::Internal::BookmarkHolder::NO_OP = T.let(T.unsafe(nil), T.untyped)

# source://neo4j-ruby-driver//ruby/neo4j/driver/config.rb#0
module Neo4j::Driver::Internal::Cluster; end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/cluster_composition.rb#4
class Neo4j::Driver::Internal::Cluster::ClusterComposition < ::Struct
  # @return [ClusterComposition] a new instance of ClusterComposition
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/cluster_composition.rb#5
  def initialize(expiration_timestamp:, database_name:, readers: T.unsafe(nil), writers: T.unsafe(nil), routers: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/cluster_composition.rb#13
  def has_routers_and_readers?; end

  # @return [Boolean]
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/cluster_composition.rb#9
  def has_writers?; end

  class << self
    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/cluster_composition.rb#28
    def expiration_timestamp(now, record); end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/cluster_composition.rb#17
    def parse(record, now); end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/cluster_composition.rb#33
    def servers(role); end
  end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/cluster_composition_lookup_result.rb#4
class Neo4j::Driver::Internal::Cluster::ClusterCompositionLookupResult
  # @return [ClusterCompositionLookupResult] a new instance of ClusterCompositionLookupResult
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/cluster_composition_lookup_result.rb#7
  def initialize(composition, resolved_initial_routers = T.unsafe(nil)); end

  # Returns the value of attribute cluster_composition.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/cluster_composition_lookup_result.rb#5
  def cluster_composition; end

  # Returns the value of attribute resolved_initial_routers.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/cluster_composition_lookup_result.rb#5
  def resolved_initial_routers; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/cluster_routing_table.rb#4
class Neo4j::Driver::Internal::Cluster::ClusterRoutingTable
  # @return [ClusterRoutingTable] a new instance of ClusterRoutingTable
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/cluster_routing_table.rb#7
  def initialize(of_database, _clock, *routing_addresses); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/cluster_routing_table.rb#69
  def database; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/cluster_routing_table.rb#88
  def expiration_timestamp; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/cluster_routing_table.rb#42
  def forget(address); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/cluster_routing_table.rb#73
  def forget_writer(to_remove); end

  # @return [Boolean]
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/cluster_routing_table.rb#27
  def has_been_stale_for?(extra_time); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/cluster_routing_table.rb#84
  def prefer_initial_router; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/cluster_routing_table.rb#51
  def readers; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/cluster_routing_table.rb#80
  def replace_router_if_present(old_router, new_router); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/cluster_routing_table.rb#59
  def routers; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/cluster_routing_table.rb#63
  def servers; end

  # @return [Boolean]
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/cluster_routing_table.rb#18
  def stale_for?(mode); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/cluster_routing_table.rb#92
  def to_s; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/cluster_routing_table.rb#31
  def update(cluster); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/cluster_routing_table.rb#55
  def writers; end

  private

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/cluster_routing_table.rb#104
  def new_with_address_replaced_if_present(addresses, old_address, new_address); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/cluster_routing_table.rb#108
  def new_with_reused_addresses(*addresses); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/cluster_routing_table.rb#100
  def new_without_address_if_present(addresses, address_to_skip); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/cluster_routing_table.rb#112
  def to_bolt_server_address(address); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/cluster_routing_table.rb#5
Neo4j::Driver::Internal::Cluster::ClusterRoutingTable::MIN_ROUTERS = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/identity_resolver.rb#4
class Neo4j::Driver::Internal::Cluster::IdentityResolver
  private

  def resolve(_arg0); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/identity_resolver.rb#5
Neo4j::Driver::Internal::Cluster::IdentityResolver::IDENTITY_RESOLVER = T.let(T.unsafe(nil), Neo4j::Driver::Internal::Cluster::IdentityResolver)

# source://neo4j-ruby-driver//ruby/neo4j/driver.rb#0
module Neo4j::Driver::Internal::Cluster::Loadbalancing; end

# Load balancing strategy that finds server with the least amount of active (checked out of the pool) connections from given readers or writers. It finds a
# start index for iteration in a round-robin fashion. This is done to prevent choosing same first address over and over when all addresses have the same amount
# of active connections.
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/loadbalancing/least_connected_load_balancing_strategy.rb#9
class Neo4j::Driver::Internal::Cluster::Loadbalancing::LeastConnectedLoadBalancingStrategy
  # @return [LeastConnectedLoadBalancingStrategy] a new instance of LeastConnectedLoadBalancingStrategy
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/loadbalancing/least_connected_load_balancing_strategy.rb#11
  def initialize(connection_pool, logger); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/loadbalancing/least_connected_load_balancing_strategy.rb#19
  def select_reader(known_readers); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/loadbalancing/least_connected_load_balancing_strategy.rb#23
  def select_writer(known_writers); end

  private

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/loadbalancing/least_connected_load_balancing_strategy.rb#29
  def select(addresses, addresses_index, address_type); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/loadbalancing/load_balancer.rb#5
class Neo4j::Driver::Internal::Cluster::Loadbalancing::LoadBalancer
  # @return [LoadBalancer] a new instance of LoadBalancer
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/loadbalancing/load_balancer.rb#13
  def initialize(initial_router, settings, connection_pool, event_executor_group, logger, load_balancing_strategy, resolver, &domain_name_resolver); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/loadbalancing/load_balancer.rb#23
  def acquire_connection(context); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/loadbalancing/load_balancer.rb#11
  def close(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/loadbalancing/load_balancer.rb#37
  def routing_table_registry; end

  # @return [Boolean]
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/loadbalancing/load_balancer.rb#41
  def supports_multi_db?; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/loadbalancing/load_balancer.rb#30
  def verify_connectivity; end

  private

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/loadbalancing/load_balancer.rb#64
  def acquire(mode, routing_table, attempt_errors = T.unsafe(nil)); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/loadbalancing/load_balancer.rb#87
  def addresses_by_mode(mode, routing_table); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/loadbalancing/load_balancer.rb#113
  def create_rediscovery(event_executor_group, initial_router, resolver, settings, clock, logger, domain_name_resolver); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/loadbalancing/load_balancer.rb#109
  def create_routing_tables(connection_pool, rediscovery, settings, clock, logger); end

  # @return [Boolean]
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/loadbalancing/load_balancer.rb#57
  def private_suports_multi_db?(address); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/loadbalancing/load_balancer.rb#98
  def select_address(mode, addresses); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/loadbalancing/load_balancer.rb#118
  def unknown_mode(mode); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/loadbalancing/load_balancer.rb#9
Neo4j::Driver::Internal::Cluster::Loadbalancing::LoadBalancer::BOLT_SERVER_ADDRESSES_EMPTY_ARRAY = T.let(T.unsafe(nil), Array)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/loadbalancing/load_balancer.rb#8
Neo4j::Driver::Internal::Cluster::Loadbalancing::LoadBalancer::CONNECTION_ACQUISITION_ATTEMPT_FAILURE_MESSAGE = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/loadbalancing/load_balancer.rb#7
Neo4j::Driver::Internal::Cluster::Loadbalancing::LoadBalancer::CONNECTION_ACQUISITION_COMPLETION_EXCEPTION_MESSAGE = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/loadbalancing/load_balancer.rb#6
Neo4j::Driver::Internal::Cluster::Loadbalancing::LoadBalancer::CONNECTION_ACQUISITION_COMPLETION_FAILURE_MESSAGE = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/loadbalancing/round_robin_array_index.rb#5
class Neo4j::Driver::Internal::Cluster::Loadbalancing::RoundRobinArrayIndex < ::Concurrent::AtomicFixnum
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/loadbalancing/round_robin_array_index.rb#6
  def next(array_length); end
end

# This implementation of the {@link RoutingProcedureRunner} works with multi database versions of Neo4j calling
# the procedure `dbms.routing.getRoutingTable`
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/multi_databases_routing_procedure_runner.rb#7
class Neo4j::Driver::Internal::Cluster::MultiDatabasesRoutingProcedureRunner < ::Neo4j::Driver::Internal::Cluster::SingleDatabaseRoutingProcedureRunner
  private

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/multi_databases_routing_procedure_runner.rb#13
  def bookmark_holder(bookmark); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/multi_databases_routing_procedure_runner.rb#25
  def connection(connection); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/multi_databases_routing_procedure_runner.rb#17
  def procedure_query(server_version, database_name); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/multi_databases_routing_procedure_runner.rb#8
Neo4j::Driver::Internal::Cluster::MultiDatabasesRoutingProcedureRunner::DATABASE_NAME = T.let(T.unsafe(nil), Symbol)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/multi_databases_routing_procedure_runner.rb#9
Neo4j::Driver::Internal::Cluster::MultiDatabasesRoutingProcedureRunner::MULTI_DB_GET_ROUTING_TABLE = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/rediscovery_impl.rb#4
class Neo4j::Driver::Internal::Cluster::RediscoveryImpl
  # @return [RediscoveryImpl] a new instance of RediscoveryImpl
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/rediscovery_impl.rb#11
  def initialize(initial_router, settings, provider, event_executor_group, resolver, logger, domain_name_resolver); end

  # @param routingTable current routing table of the given database.
  # @param connectionPool connection pool.
  # @return new cluster composition and an optional set of resolved initial router addresses.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/rediscovery_impl.rb#27
  def lookup_cluster_composition(routing_table, connection_pool, bookmark, impersonated_user, failures = T.unsafe(nil), previous_delay = T.unsafe(nil), base_error = T.unsafe(nil)); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/rediscovery_impl.rb#45
  def resolve; end

  private

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/rediscovery_impl.rb#107
  def handle_routing_procedure_error(error, routing_table, router_address, base_error); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/rediscovery_impl.rb#64
  def lookup(routing_table, connection_pool, bookmark, impersonated_user, base_error); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/rediscovery_impl.rb#89
  def lookup_on_initial_router(routing_table, connection_pool, seen_servers, bookmark, impersonated_user, base_error); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/rediscovery_impl.rb#78
  def lookup_on_initial_router_then_on_known_routers(routing_table, connection_pool, bookmark, impersonated_user, base_error); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/rediscovery_impl.rb#83
  def lookup_on_known_routers(routing_table, connection_pool, seen_servers, bookmark, impersonated_user, base_error); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/rediscovery_impl.rb#72
  def lookup_on_known_routers_then_on_initial_router(routing_table, connection_pool, bookmark, impersonated_user, base_error); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/rediscovery_impl.rb#97
  def lookup_on_router(router_address, resolve_address, routing_table, connection_pool, seen_servers, bookmark, impersonated_user, base_error); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/rediscovery_impl.rb#120
  def must_abort_discovery(error); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/rediscovery_impl.rb#141
  def resolve_all_by_domain_name(address); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/rediscovery_impl.rb#132
  def resolve_by_domain_name_or_throw_completion_exception(address, routing_table); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/rediscovery_impl.rb#8
Neo4j::Driver::Internal::Cluster::RediscoveryImpl::INVALID_BOOKMARK_CODE = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/rediscovery_impl.rb#9
Neo4j::Driver::Internal::Cluster::RediscoveryImpl::INVALID_BOOKMARK_MIXTURE_CODE = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/rediscovery_impl.rb#5
Neo4j::Driver::Internal::Cluster::RediscoveryImpl::NO_ROUTERS_AVAILABLE = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/rediscovery_impl.rb#7
Neo4j::Driver::Internal::Cluster::RediscoveryImpl::RECOVERABLE_DISCOVERY_ERROR_WITH_SERVER = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/rediscovery_impl.rb#6
Neo4j::Driver::Internal::Cluster::RediscoveryImpl::RECOVERABLE_ROUTING_ERROR = T.let(T.unsafe(nil), String)

# This implementation of the {@link RoutingProcedureRunner} access the routing procedure
# through the bolt's ROUTE message.
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/route_message_routing_procedure_runner.rb#6
class Neo4j::Driver::Internal::Cluster::RouteMessageRoutingProcedureRunner
  # @return [RouteMessageRoutingProcedureRunner] a new instance of RouteMessageRoutingProcedureRunner
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/route_message_routing_procedure_runner.rb#9
  def initialize(routing_context); end

  # Sets the attribute routing_table
  #
  # @param value the value to set the attribute routing_table to.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/route_message_routing_procedure_runner.rb#7
  def routing_table=(_arg0); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/route_message_routing_procedure_runner.rb#13
  def run(connection, database_name, bookmark, impersonated_user); end

  private

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/route_message_routing_procedure_runner.rb#36
  def query(database_name); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/route_message_routing_procedure_runner.rb#32
  def to_direct_connection(connection, database_name, impersonated_user); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/route_message_routing_procedure_runner.rb#28
  def to_record(routing_table); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_context.rb#4
class Neo4j::Driver::Internal::Cluster::RoutingContext
  include ::Neo4j::Driver::Internal::Scheme

  # @return [RoutingContext] a new instance of RoutingContext
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_context.rb#9
  def initialize(uri = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_context.rb#19
  def defined?; end

  # @return [Boolean]
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_context.rb#27
  def server_routing_enabled?; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_context.rb#23
  def to_h; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_context.rb#31
  def to_s; end

  private

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_context.rb#37
  def parse_parameters(uri); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_context.rb#69
  def trim_and_verify(string, name, uri); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_context.rb#61
  def trim_and_verify_key(s, key, uri); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_context.rb#6
Neo4j::Driver::Internal::Cluster::RoutingContext::EMPTY = T.let(T.unsafe(nil), Neo4j::Driver::Internal::Cluster::RoutingContext)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_context.rb#7
Neo4j::Driver::Internal::Cluster::RoutingContext::ROUTING_ADDRESS_KEY = T.let(T.unsafe(nil), Symbol)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_procedure_cluster_composition_provider.rb#4
class Neo4j::Driver::Internal::Cluster::RoutingProcedureClusterCompositionProvider
  # @return [RoutingProcedureClusterCompositionProvider] a new instance of RoutingProcedureClusterCompositionProvider
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_procedure_cluster_composition_provider.rb#7
  def initialize(_clock, routing_context); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_procedure_cluster_composition_provider.rb#13
  def get_cluster_composition(connection, database_name, bookmark, impersonated_user); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_procedure_cluster_composition_provider.rb#53
  def invoked_procedure_string(response); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_procedure_cluster_composition_provider.rb#25
  def process_routing_response(response); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_procedure_cluster_composition_provider.rb#5
Neo4j::Driver::Internal::Cluster::RoutingProcedureClusterCompositionProvider::PROTOCOL_ERROR_MESSAGE = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_procedure_response.rb#4
class Neo4j::Driver::Internal::Cluster::RoutingProcedureResponse
  # @return [RoutingProcedureResponse] a new instance of RoutingProcedureResponse
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_procedure_response.rb#7
  def initialize(procedure, records: T.unsafe(nil), error: T.unsafe(nil)); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_procedure_response.rb#25
  def error; end

  # Returns the value of attribute procedure.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_procedure_response.rb#5
  def procedure; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_procedure_response.rb#17
  def records; end

  # @return [Boolean]
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_procedure_response.rb#13
  def success?; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_settings.rb#4
class Neo4j::Driver::Internal::Cluster::RoutingSettings
  # @return [RoutingSettings] a new instance of RoutingSettings
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_settings.rb#7
  def initialize(max_routing_failures, retry_timeout_delay, routing_table_purge_delay, routing_context = T.unsafe(nil)); end

  # Returns the value of attribute max_routing_failures.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_settings.rb#5
  def max_routing_failures; end

  # Returns the value of attribute retry_timeout_delay.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_settings.rb#5
  def retry_timeout_delay; end

  # Returns the value of attribute routing_context.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_settings.rb#5
  def routing_context; end

  # Returns the value of attribute routing_table_purge_delay.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_settings.rb#5
  def routing_table_purge_delay; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_settings.rb#18
  def with_routing_context(new_routing_context); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_settings.rb#16
Neo4j::Driver::Internal::Cluster::RoutingSettings::DEFAULT = T.let(T.unsafe(nil), Neo4j::Driver::Internal::Cluster::RoutingSettings)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_settings.rb#15
Neo4j::Driver::Internal::Cluster::RoutingSettings::STALE_ROUTING_TABLE_PURGE_DELAY = T.let(T.unsafe(nil), ActiveSupport::Duration)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_table_handler_impl.rb#4
class Neo4j::Driver::Internal::Cluster::RoutingTableHandlerImpl
  # @return [RoutingTableHandlerImpl] a new instance of RoutingTableHandlerImpl
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_table_handler_impl.rb#9
  def initialize(routing_table, rediscovery, connection_pool, routing_table_registry, logger, routing_table_purge_delay); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_table_handler_impl.rb#29
  def ensure_routing_table(context); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_table_handler_impl.rb#20
  def on_connection_failure(address); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_table_handler_impl.rb#25
  def on_write_failure(address); end

  # Returns the value of attribute routing_table.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_table_handler_impl.rb#5
  def routing_table; end

  # This method cannot be synchronized as it will be visited by all routing table handler's threads concurrently
  #
  # @return [Boolean]
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_table_handler_impl.rb#89
  def routing_table_aged?; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_table_handler_impl.rb#7
  def servers(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_table_handler_impl.rb#47
  def update_routing_table(composition_lookup_result); end

  private

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_table_handler_impl.rb#77
  def cluster_composition_lookup_failed(error); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_table_handler_impl.rb#59
  def fresh_cluster_composition_fetched(composition_lookup_result); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_table_registry_impl.rb#4
class Neo4j::Driver::Internal::Cluster::RoutingTableRegistryImpl
  # @return [RoutingTableRegistryImpl] a new instance of RoutingTableRegistryImpl
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_table_registry_impl.rb#5
  def initialize(connection_pool, rediscovery, clock, logger, routing_table_purge_delay); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_table_registry_impl.rb#52
  def all_servers; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_table_registry_impl.rb#16
  def ensure_routing_table(context); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_table_registry_impl.rb#80
  def get_or_create(database_name); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_table_registry_impl.rb#78
  def key?(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_table_registry_impl.rb#58
  def remove(database_name); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_table_registry_impl.rb#63
  def remove_aged; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_table_registry_impl.rb#72
  def routing_table_handler(database_name); end

  private

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_table_registry_impl.rb#22
  def ensure_database_name_is_completed(context); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_table_registry_impl.rb#110
class Neo4j::Driver::Internal::Cluster::RoutingTableRegistryImpl::ConnectionContextAndHandler
  # @return [ConnectionContextAndHandler] a new instance of ConnectionContextAndHandler
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_table_registry_impl.rb#113
  def initialize(context, handler); end

  # Returns the value of attribute context.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_table_registry_impl.rb#111
  def context; end

  # Returns the value of attribute handler.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_table_registry_impl.rb#111
  def handler; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_table_registry_impl.rb#107
class Neo4j::Driver::Internal::Cluster::RoutingTableRegistryImpl::Principal < ::Struct; end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_table_registry_impl.rb#92
class Neo4j::Driver::Internal::Cluster::RoutingTableRegistryImpl::RoutingTableHandlerFactory
  # @return [RoutingTableHandlerFactory] a new instance of RoutingTableHandlerFactory
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_table_registry_impl.rb#93
  def initialize(connection_pool, rediscovery, clock, logger, routing_table_purge_delay); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/routing_table_registry_impl.rb#101
  def new_instance(database_name, all_tables); end
end

# This implementation of the {@link RoutingProcedureRunner} works with single database versions of Neo4j calling
# the procedure `dbms.cluster.routing.getRoutingTable`
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/single_database_routing_procedure_runner.rb#7
class Neo4j::Driver::Internal::Cluster::SingleDatabaseRoutingProcedureRunner
  # @return [SingleDatabaseRoutingProcedureRunner] a new instance of SingleDatabaseRoutingProcedureRunner
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/single_database_routing_procedure_runner.rb#11
  def initialize(context); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/single_database_routing_procedure_runner.rb#15
  def run(connection, database_name, bookmark, impersonated_user); end

  private

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/single_database_routing_procedure_runner.rb#43
  def bookmark_holder(_ignored); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/single_database_routing_procedure_runner.rb#31
  def connection(connection); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/single_database_routing_procedure_runner.rb#63
  def handle_error(procedure, error); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/single_database_routing_procedure_runner.rb#35
  def procedure_query(server_version, database_name); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/single_database_routing_procedure_runner.rb#54
  def release_connection(connection); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/single_database_routing_procedure_runner.rb#47
  def run_procedure(connection, procedure, bookmark_holder); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/single_database_routing_procedure_runner.rb#9
Neo4j::Driver::Internal::Cluster::SingleDatabaseRoutingProcedureRunner::GET_ROUTING_TABLE = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cluster/single_database_routing_procedure_runner.rb#8
Neo4j::Driver::Internal::Cluster::SingleDatabaseRoutingProcedureRunner::ROUTING_CONTEXT = T.let(T.unsafe(nil), Symbol)

# The connection settings are used whenever a new connection is
# established to a server, specifically as part of the INIT request.
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/connection_settings.rb#6
class Neo4j::Driver::Internal::ConnectionSettings
  # @return [ConnectionSettings] a new instance of ConnectionSettings
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/connection_settings.rb#9
  def initialize(auth_token, user_agent, connect_timeout_millis); end

  # Returns the value of attribute auth_token.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/connection_settings.rb#7
  def auth_token; end

  # Returns the value of attribute connect_timeout_millis.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/connection_settings.rb#7
  def connect_timeout_millis; end

  # Returns the value of attribute user_agent.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/connection_settings.rb#7
  def user_agent; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver.rb#0
module Neo4j::Driver::Internal::Cursor; end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cursor/async_result_cursor_impl.rb#4
class Neo4j::Driver::Internal::Cursor::AsyncResultCursorImpl
  # @return [AsyncResultCursorImpl] a new instance of AsyncResultCursorImpl
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cursor/async_result_cursor_impl.rb#7
  def initialize(run_handler, pull_all_handler); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cursor/async_result_cursor_impl.rb#5
  def consume_async(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cursor/async_result_cursor_impl.rb#35
  def discard_all_failure_async; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cursor/async_result_cursor_impl.rb#12
  def keys; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cursor/async_result_cursor_impl.rb#31
  def list_async(&map_function); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cursor/async_result_cursor_impl.rb#45
  def map_successful_run_completion_async; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cursor/async_result_cursor_impl.rb#5
  def next_async(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cursor/async_result_cursor_impl.rb#5
  def peek_async(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cursor/async_result_cursor_impl.rb#40
  def pull_all_failure_async; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cursor/async_result_cursor_impl.rb#49
  def run_error; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cursor/async_result_cursor_impl.rb#16
  def single_async; end
end

# Used by Bolt V1, V2, V3
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cursor/async_result_cursor_only_factory.rb#5
class Neo4j::Driver::Internal::Cursor::AsyncResultCursorOnlyFactory
  # @return [AsyncResultCursorOnlyFactory] a new instance of AsyncResultCursorOnlyFactory
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cursor/async_result_cursor_only_factory.rb#6
  def initialize(connection, run_message, run_handler, pull_handler); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cursor/async_result_cursor_only_factory.rb#14
  def async_result; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cursor/disposable_async_result_cursor.rb#4
class Neo4j::Driver::Internal::Cursor::DisposableAsyncResultCursor
  include ::Enumerable

  # @return [DisposableAsyncResultCursor] a new instance of DisposableAsyncResultCursor
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cursor/disposable_async_result_cursor.rb#8
  def initialize(delegate); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cursor/disposable_async_result_cursor.rb#12
  def consume_async; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cursor/disposable_async_result_cursor.rb#42
  def discard_all_failure_async; end

  # @return [Boolean]
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cursor/disposable_async_result_cursor.rb#51
  def disposed?; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cursor/disposable_async_result_cursor.rb#32
  def each(&action); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cursor/disposable_async_result_cursor.rb#6
  def keys(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cursor/disposable_async_result_cursor.rb#37
  def list_async(&block); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cursor/disposable_async_result_cursor.rb#55
  def map_successful_run_completion_async; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cursor/disposable_async_result_cursor.rb#17
  def next_async; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cursor/disposable_async_result_cursor.rb#22
  def peek_async; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cursor/disposable_async_result_cursor.rb#6
  def pull_all_failure_async(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cursor/disposable_async_result_cursor.rb#27
  def single_async; end

  private

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cursor/disposable_async_result_cursor.rb#47
  def assert_not_disposed; end
end

# Bolt V4
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cursor/result_cursor_factory_impl.rb#5
class Neo4j::Driver::Internal::Cursor::ResultCursorFactoryImpl
  # @return [ResultCursorFactoryImpl] a new instance of ResultCursorFactoryImpl
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cursor/result_cursor_factory_impl.rb#6
  def initialize(connection, run_message, run_handler, pull_handler, pull_all_handler); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cursor/result_cursor_factory_impl.rb#14
  def async_result; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cursor/rx_result_cursor_impl.rb#4
class Neo4j::Driver::Internal::Cursor::RxResultCursorImpl
  # @return [RxResultCursorImpl] a new instance of RxResultCursorImpl
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cursor/rx_result_cursor_impl.rb#10
  def initialize(run_error, run_handler, pull_handler); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cursor/rx_result_cursor_impl.rb#7
  def cancel(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cursor/rx_result_cursor_impl.rb#42
  def discard_all_failure_async; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cursor/rx_result_cursor_impl.rb#8
  def done?(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cursor/rx_result_cursor_impl.rb#26
  def install_record_consumer(record_consumer); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cursor/rx_result_cursor_impl.rb#22
  def keys; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cursor/rx_result_cursor_impl.rb#49
  def pull_all_failure_async; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cursor/rx_result_cursor_impl.rb#36
  def request(n); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cursor/rx_result_cursor_impl.rb#58
  def summary_async; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cursor/rx_result_cursor_impl.rb#63
  def summary_stage; end

  private

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cursor/rx_result_cursor_impl.rb#75
  def assert_run_completed_successfully; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cursor/rx_result_cursor_impl.rb#81
  def install_summary_consumer; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cursor/rx_result_cursor_impl.rb#5
Neo4j::Driver::Internal::Cursor::RxResultCursorImpl::DISCARD_RECORD_CONSUMER = T.let(T.unsafe(nil), Proc)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cursor/rx_result_cursor_impl.rb#95
class Neo4j::Driver::Internal::Cursor::RxResultCursorImpl::RecordConsumerStatus
  # @return [RecordConsumerStatus] a new instance of RecordConsumerStatus
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cursor/rx_result_cursor_impl.rb#98
  def initialize(installed, discard_consumer); end

  # Returns the value of attribute discard_consumer.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cursor/rx_result_cursor_impl.rb#96
  def discard_consumer; end

  # Returns the value of attribute installed.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cursor/rx_result_cursor_impl.rb#96
  def installed; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cursor/rx_result_cursor_impl.rb#105
Neo4j::Driver::Internal::Cursor::RxResultCursorImpl::RecordConsumerStatus::DISCARD_INSTALLED = T.let(T.unsafe(nil), Neo4j::Driver::Internal::Cursor::RxResultCursorImpl::RecordConsumerStatus)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cursor/rx_result_cursor_impl.rb#104
Neo4j::Driver::Internal::Cursor::RxResultCursorImpl::RecordConsumerStatus::INSTALLED = T.let(T.unsafe(nil), Neo4j::Driver::Internal::Cursor::RxResultCursorImpl::RecordConsumerStatus)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/cursor/rx_result_cursor_impl.rb#103
Neo4j::Driver::Internal::Cursor::RxResultCursorImpl::RecordConsumerStatus::NOT_INSTALLED = T.let(T.unsafe(nil), Neo4j::Driver::Internal::Cursor::RxResultCursorImpl::RecordConsumerStatus)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/database_name_util.rb#3
class Neo4j::Driver::Internal::DatabaseNameUtil
  class << self
    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/database_name_util.rb#23
    def database(name); end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/database_name_util.rb#15
    def default_database; end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/database_name_util.rb#19
    def system_database; end
  end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/database_name_util.rb#9
Neo4j::Driver::Internal::DatabaseNameUtil::DEFAULT_DATABASE = T.let(T.unsafe(nil), Neo4j::Driver::Internal::InternalDatabaseName)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/database_name_util.rb#4
Neo4j::Driver::Internal::DatabaseNameUtil::DEFAULT_DATABASE_NAME = T.let(T.unsafe(nil), T.untyped)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/database_name_util.rb#10
Neo4j::Driver::Internal::DatabaseNameUtil::SYSTEM_DATABASE = T.let(T.unsafe(nil), Neo4j::Driver::Internal::InternalDatabaseName)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/database_name_util.rb#5
Neo4j::Driver::Internal::DatabaseNameUtil::SYSTEM_DATABASE_NAME = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/default_bookmark_holder.rb#3
class Neo4j::Driver::Internal::DefaultBookmarkHolder < ::Neo4j::Driver::Internal::ReadOnlyBookmarkHolder
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/default_bookmark_holder.rb#4
  def bookmark=(bookmark); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/default_domain_name_resolver.rb#3
class Neo4j::Driver::Internal::DefaultDomainNameResolver
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/default_domain_name_resolver.rb#6
  def resolve(name); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/default_domain_name_resolver.rb#4
Neo4j::Driver::Internal::DefaultDomainNameResolver::INSTANCE = T.let(T.unsafe(nil), Neo4j::Driver::Internal::DefaultDomainNameResolver)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/direct_connection_provider.rb#3
class Neo4j::Driver::Internal::DirectConnectionProvider
  # @return [DirectConnectionProvider] a new instance of DirectConnectionProvider
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/direct_connection_provider.rb#6
  def initialize(address, connection_pool); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/direct_connection_provider.rb#13
  def acquire_connection(context); end

  # Returns the value of attribute address.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/direct_connection_provider.rb#4
  def address; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/direct_connection_provider.rb#11
  def close(*_arg0, **_arg1, &_arg2); end

  # @return [Boolean]
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/direct_connection_provider.rb#23
  def supports_multi_db?; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/direct_connection_provider.rb#19
  def verify_connectivity; end

  private

  # Used only for grabbing a connection with the server after hello message.
  # This connection cannot be directly used for running any queries as it is missing necessary connection context
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/direct_connection_provider.rb#35
  def private_acquire_connection; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/driver_factory.rb#2
class Neo4j::Driver::Internal::DriverFactory
  include ::Neo4j::Driver::Internal::Scheme

  # @return [DriverFactory] a new instance of DriverFactory
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/driver_factory.rb#6
  def initialize(domain_name_resolver = T.unsafe(nil)); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/driver_factory.rb#10
  def new_instance(uri, auth_token, routing_settings, retry_settings, config, security_plan, event_loop_group = T.unsafe(nil)); end

  protected

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/driver_factory.rb#112
  def close_connection_pool_and_suppress_error(connection_pool, main_error); end

  # def getDomainNameResolver(name)
  #   domain_name_resolver(name).map { |addrinfo| java.net.InetAddress.getByName(addrinfo.canonname) }.to_java(java.net.InetAddress)
  # end
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/driver_factory.rb#122
  def domain_name_resolver(name); end

  private

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/driver_factory.rb#56
  def assert_no_routing_context(uri, routing_settings); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/driver_factory.rb#106
  def create_bootstrap(**args); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/driver_factory.rb#31
  def create_connection_pool(auth_token, security_plan, bootstrap, metrics_provider, config, owns_event_loop_group, routing_context); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/driver_factory.rb#63
  def create_connector(settings, security_plan, config, clock, routing_context); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/driver_factory.rb#81
  def create_direct_driver(securityPlan, address, connection_pool, retryLogic, metricsProvider, config); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/driver_factory.rb#68
  def create_driver(uri, security_plan, address, connection_pool, eventExecutorGroup, routing_settings, retryLogic, metricsProvider, config); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/driver_factory.rb#44
  def create_driver_metrics(config); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/driver_factory.rb#98
  def create_load_balancer(address, connection_pool, eventExecutorGroup, config, routing_settings); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/driver_factory.rb#52
  def create_resolver(config); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/driver_factory.rb#86
  def create_routing_driver(securityPlan, address, connection_pool, eventExecutorGroup, routing_settings, retryLogic, metricsProvider, config); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/driver_factory.rb#91
  def driver(type, security_plan, address, connection_provider, retry_logic, metrics_provider, config); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/driver_factory.rb#4
Neo4j::Driver::Internal::DriverFactory::NO_ROUTING_CONTEXT_ERROR_MESSAGE = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//lib/neo4j/driver/internal/duration_normalizer.rb#6
module Neo4j::Driver::Internal::DurationNormalizer
  class << self
    # source://neo4j-ruby-driver//lib/neo4j/driver/internal/duration_normalizer.rb#20
    def milliseconds(duration); end

    # source://neo4j-ruby-driver//lib/neo4j/driver/internal/duration_normalizer.rb#8
    def normalize(object); end

    private

    # source://neo4j-ruby-driver//lib/neo4j/driver/internal/duration_normalizer.rb#35
    def days(parts); end

    # source://neo4j-ruby-driver//lib/neo4j/driver/internal/duration_normalizer.rb#26
    def divmod(number, factor); end

    # source://neo4j-ruby-driver//lib/neo4j/driver/internal/duration_normalizer.rb#31
    def months(parts); end

    # source://neo4j-ruby-driver//lib/neo4j/driver/internal/duration_normalizer.rb#39
    def seconds(parts); end
  end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/config.rb#0
module Neo4j::Driver::Internal::Handlers; end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/begin_tx_response_handler.rb#4
class Neo4j::Driver::Internal::Handlers::BeginTxResponseHandler
  include ::Neo4j::Driver::Internal::Spi::ResponseHandler

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/begin_tx_response_handler.rb#10
  def on_failure(error); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/begin_tx_response_handler.rb#14
  def on_record(fields); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/begin_tx_response_handler.rb#7
  def on_success(_metadata); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/channel_releasing_reset_response_handler.rb#4
class Neo4j::Driver::Internal::Handlers::ChannelReleasingResetResponseHandler < ::Neo4j::Driver::Internal::Handlers::ResetResponseHandler
  # @return [ChannelReleasingResetResponseHandler] a new instance of ChannelReleasingResetResponseHandler
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/channel_releasing_reset_response_handler.rb#5
  def initialize(channel, pool, message_dispatcher, log, release_future); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/channel_releasing_reset_response_handler.rb#12
  def reset_completed(success); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/commit_tx_response_handler.rb#4
class Neo4j::Driver::Internal::Handlers::CommitTxResponseHandler
  include ::Neo4j::Driver::Internal::Spi::ResponseHandler

  # @return [CommitTxResponseHandler] a new instance of CommitTxResponseHandler
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/commit_tx_response_handler.rb#7
  def initialize(result_holder); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/commit_tx_response_handler.rb#15
  def on_failure(error); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/commit_tx_response_handler.rb#19
  def on_record(fields); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/commit_tx_response_handler.rb#11
  def on_success(metadata); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/hello_response_handler.rb#4
class Neo4j::Driver::Internal::Handlers::HelloResponseHandler
  include ::Neo4j::Driver::Internal::Spi::ResponseHandler

  # @return [HelloResponseHandler] a new instance of HelloResponseHandler
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/hello_response_handler.rb#11
  def initialize(channel, protocol_version); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/hello_response_handler.rb#9
  def attributes(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/hello_response_handler.rb#36
  def on_failure(error); end

  # @raise [NotImplementedError]
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/hello_response_handler.rb#41
  def on_record(_fields); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/hello_response_handler.rb#16
  def on_success(metadata); end

  private

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/hello_response_handler.rb#47
  def extract_connection_id(metadata); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/hello_response_handler.rb#57
  def process_configuration_hints(metadata); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/hello_response_handler.rb#7
Neo4j::Driver::Internal::Handlers::HelloResponseHandler::CONFIGURATION_HINTS_KEY = T.let(T.unsafe(nil), Symbol)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/hello_response_handler.rb#6
Neo4j::Driver::Internal::Handlers::HelloResponseHandler::CONNECTION_ID_METADATA_KEY = T.let(T.unsafe(nil), Symbol)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/hello_response_handler.rb#8
Neo4j::Driver::Internal::Handlers::HelloResponseHandler::CONNECTION_RECEIVE_TIMEOUT_SECONDS_KEY = T.let(T.unsafe(nil), Symbol)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/init_response_handler.rb#4
class Neo4j::Driver::Internal::Handlers::InitResponseHandler
  include ::Neo4j::Driver::Internal::Spi::ResponseHandler

  # @return [InitResponseHandler] a new instance of InitResponseHandler
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/init_response_handler.rb#7
  def initialize(connection_initialized_promise); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/init_response_handler.rb#24
  def on_failure(error); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/init_response_handler.rb#28
  def on_record(fields); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/init_response_handler.rb#12
  def on_success(_metadata); end
end

# This is the Pull All response handler that handles pull all messages in Bolt v3 and previous protocol versions.
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/legacy_pull_all_response_handler.rb#5
class Neo4j::Driver::Internal::Handlers::LegacyPullAllResponseHandler
  include ::Neo4j::Driver::Internal::Spi::ResponseHandler

  # @return [LegacyPullAllResponseHandler] a new instance of LegacyPullAllResponseHandler
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/legacy_pull_all_response_handler.rb#10
  def initialize(query, run_response_handler, connection, metadata_extractor, completion_listener); end

  # @return [Boolean]
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/legacy_pull_all_response_handler.rb#19
  def can_manage_auto_read?; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/legacy_pull_all_response_handler.rb#78
  def consume_async; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/legacy_pull_all_response_handler.rb#62
  def disable_auto_read_management; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/legacy_pull_all_response_handler.rb#85
  def list_async(&block); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/legacy_pull_all_response_handler.rb#74
  def next_async; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/legacy_pull_all_response_handler.rb#33
  def on_failure(error); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/legacy_pull_all_response_handler.rb#52
  def on_record(fields); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/legacy_pull_all_response_handler.rb#23
  def on_success(metadata); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/legacy_pull_all_response_handler.rb#66
  def peek_async; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/legacy_pull_all_response_handler.rb#97
  def pre_populate_records; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/legacy_pull_all_response_handler.rb#101
  def pull_all_failure_async; end

  private

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/legacy_pull_all_response_handler.rb#178
  def complete_failure_future(error); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/legacy_pull_all_response_handler.rb#167
  def complete_record_future(record); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/legacy_pull_all_response_handler.rb#134
  def dequeue_record; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/legacy_pull_all_response_handler.rb#193
  def disable_auto_read; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/legacy_pull_all_response_handler.rb#189
  def enable_auto_read; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/legacy_pull_all_response_handler.rb#118
  def enqueue_record(record); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/legacy_pull_all_response_handler.rb#161
  def extract_failure; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/legacy_pull_all_response_handler.rb#184
  def extract_result_summary(metadata); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/legacy_pull_all_response_handler.rb#172
  def fail_record_future(error); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/legacy_pull_all_response_handler.rb#146
  def records_as_list(map_function); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/legacy_pull_all_response_handler.rb#8
Neo4j::Driver::Internal::Handlers::LegacyPullAllResponseHandler::RECORD_BUFFER_HIGH_WATERMARK = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/legacy_pull_all_response_handler.rb#7
Neo4j::Driver::Internal::Handlers::LegacyPullAllResponseHandler::RECORD_BUFFER_LOW_WATERMARK = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/no_op_response_handler.rb#4
class Neo4j::Driver::Internal::Handlers::NoOpResponseHandler
  include ::Neo4j::Driver::Internal::Spi::ResponseHandler

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/no_op_response_handler.rb#10
  def on_failure(error); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/no_op_response_handler.rb#12
  def on_record(fields); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/no_op_response_handler.rb#8
  def on_success(metadata); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/no_op_response_handler.rb#6
Neo4j::Driver::Internal::Handlers::NoOpResponseHandler::INSTANCE = T.let(T.unsafe(nil), Neo4j::Driver::Internal::Handlers::NoOpResponseHandler)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/ping_response_handler.rb#4
class Neo4j::Driver::Internal::Handlers::PingResponseHandler
  include ::Neo4j::Driver::Internal::Spi::ResponseHandler

  # @return [PingResponseHandler] a new instance of PingResponseHandler
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/ping_response_handler.rb#7
  def initialize(result, channel, logger); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/ping_response_handler.rb#18
  def on_failure(error); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/ping_response_handler.rb#23
  def on_record(fields); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/ping_response_handler.rb#13
  def on_success(_metadata); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pull_handlers.rb#4
class Neo4j::Driver::Internal::Handlers::PullHandlers
  include ::Neo4j::Driver::Internal::Spi::ResponseHandler

  class << self
    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pull_handlers.rb#8
    def new_bolt_v3_pull_all_handler(query, run_handler, connection, bookmark_holder, tx); end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pull_handlers.rb#13
    def new_bolt_v4_auto_pull_handler(query, run_handler, connection, bookmark_holder, tx, fetch_size); end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pull_handlers.rb#18
    def new_bolt_v4_basic_pull_handler(query, run_handler, connection, bookmark_holder, tx); end

    private

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pull_handlers.rb#25
    def create_pull_response_completion_listener(connection, bookmark_holder, tx); end
  end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/config.rb#0
module Neo4j::Driver::Internal::Handlers::Pulln; end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/auto_pull_response_handler.rb#5
class Neo4j::Driver::Internal::Handlers::Pulln::AutoPullResponseHandler < ::Neo4j::Driver::Internal::Handlers::Pulln::BasicPullResponseHandler
  # @return [AutoPullResponseHandler] a new instance of AutoPullResponseHandler
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/auto_pull_response_handler.rb#9
  def initialize(query, run_response_handler, connection, metadata_extractor, completion_listener, fetch_size); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/auto_pull_response_handler.rb#75
  def consume_async; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/auto_pull_response_handler.rb#81
  def list_async(&block); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/auto_pull_response_handler.rb#71
  def next_async; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/auto_pull_response_handler.rb#63
  def peek_async; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/auto_pull_response_handler.rb#96
  def pre_populate_records; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/auto_pull_response_handler.rb#92
  def pull_all_failure_async; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/auto_pull_response_handler.rb#6
  def signal(*_arg0, **_arg1, &_arg2); end

  private

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/auto_pull_response_handler.rb#135
  def complete_record_future(record); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/auto_pull_response_handler.rb#140
  def complete_summary_future(summary); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/auto_pull_response_handler.rb#157
  def completed_with_value_if_no_failure(value); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/auto_pull_response_handler.rb#116
  def dequeue_record; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/auto_pull_response_handler.rb#109
  def enqueue_record(record); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/auto_pull_response_handler.rb#129
  def extract_failure; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/auto_pull_response_handler.rb#145
  def fail_record_future(error); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/auto_pull_response_handler.rb#151
  def fail_summary_future(error); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/auto_pull_response_handler.rb#56
  def handle_failure(error); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/auto_pull_response_handler.rb#28
  def install_record_and_summary_consumers; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/auto_pull_response_handler.rb#102
  def pull_all_async; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/auto_pull_response_handler.rb#7
Neo4j::Driver::Internal::Handlers::Pulln::AutoPullResponseHandler::LONG_MAX_VALUE = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/basic_pull_response_handler.rb#5
class Neo4j::Driver::Internal::Handlers::Pulln::BasicPullResponseHandler
  include ::Neo4j::Driver::Internal::Spi::ResponseHandler

  # @return [BasicPullResponseHandler] a new instance of BasicPullResponseHandler
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/basic_pull_response_handler.rb#9
  def initialize(query, run_response_handler, connection, metadata_extractor, completion_listener); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/basic_pull_response_handler.rb#45
  def cancel; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/basic_pull_response_handler.rb#50
  def complete_with_failure(error); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/basic_pull_response_handler.rb#55
  def complete_with_success(metadata); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/basic_pull_response_handler.rb#85
  def discard_all; end

  # @return [Boolean]
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/basic_pull_response_handler.rb#101
  def done?; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/basic_pull_response_handler.rb#76
  def handle_record(fields); end

  # @raise [Exceptions::IllegalStateException]
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/basic_pull_response_handler.rb#95
  def install_record_consumer(&record_consumer); end

  # @raise [Exceptions::IllegalStateException]
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/basic_pull_response_handler.rb#89
  def install_summary_consumer(&summary_consumer); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/basic_pull_response_handler.rb#30
  def on_failure(error); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/basic_pull_response_handler.rb#35
  def on_record(fields); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/basic_pull_response_handler.rb#25
  def on_success(metadata); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/basic_pull_response_handler.rb#40
  def request(size); end

  # Returns the value of attribute state.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/basic_pull_response_handler.rb#7
  def state; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/basic_pull_response_handler.rb#20
  def state=(state); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/basic_pull_response_handler.rb#66
  def success_has_more; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/basic_pull_response_handler.rb#81
  def write_pull(n); end

  private

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/basic_pull_response_handler.rb#110
  def add_to_request(to_add); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/basic_pull_response_handler.rb#126
  def assert_record_and_summary_consumer_installed; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/basic_pull_response_handler.rb#135
  def complete(summary, error); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/basic_pull_response_handler.rb#143
  def dispose; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/basic_pull_response_handler.rb#105
  def extract_result_summary(**metadata); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/basic_pull_response_handler.rb#149
module Neo4j::Driver::Internal::Handlers::Pulln::BasicPullResponseHandler::State; end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/basic_pull_response_handler.rb#240
Neo4j::Driver::Internal::Handlers::Pulln::BasicPullResponseHandler::State::CANCELLED_STATE = T.let(T.unsafe(nil), Neo4j::Driver::Internal::Handlers::Pulln::BasicPullResponseHandler::State::Cancelled)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/basic_pull_response_handler.rb#211
class Neo4j::Driver::Internal::Handlers::Pulln::BasicPullResponseHandler::State::Cancelled
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/basic_pull_response_handler.rb#235
  def cancel(context); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/basic_pull_response_handler.rb#222
  def on_failure(context, error); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/basic_pull_response_handler.rb#227
  def on_record(context, _fields); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/basic_pull_response_handler.rb#212
  def on_success(context, metadata); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/basic_pull_response_handler.rb#231
  def request(context, _n); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/basic_pull_response_handler.rb#292
Neo4j::Driver::Internal::Handlers::Pulln::BasicPullResponseHandler::State::FAILURE_STATE = T.let(T.unsafe(nil), Neo4j::Driver::Internal::Handlers::Pulln::BasicPullResponseHandler::State::Failed)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/basic_pull_response_handler.rb#268
class Neo4j::Driver::Internal::Handlers::Pulln::BasicPullResponseHandler::State::Failed
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/basic_pull_response_handler.rb#287
  def cancel(context); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/basic_pull_response_handler.rb#274
  def on_failure(context, error); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/basic_pull_response_handler.rb#279
  def on_record(context, _fields); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/basic_pull_response_handler.rb#269
  def on_success(context, metadata); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/basic_pull_response_handler.rb#283
  def request(context, _n); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/basic_pull_response_handler.rb#176
Neo4j::Driver::Internal::Handlers::Pulln::BasicPullResponseHandler::State::READY_STATE = T.let(T.unsafe(nil), Neo4j::Driver::Internal::Handlers::Pulln::BasicPullResponseHandler::State::Ready)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/basic_pull_response_handler.rb#150
class Neo4j::Driver::Internal::Handlers::Pulln::BasicPullResponseHandler::State::Ready
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/basic_pull_response_handler.rb#170
  def cancel(context); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/basic_pull_response_handler.rb#156
  def on_failure(context, error); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/basic_pull_response_handler.rb#161
  def on_record(context, _fields); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/basic_pull_response_handler.rb#151
  def on_success(context, metadata); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/basic_pull_response_handler.rb#165
  def request(context, n); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/basic_pull_response_handler.rb#209
Neo4j::Driver::Internal::Handlers::Pulln::BasicPullResponseHandler::State::STREAMING_STATE = T.let(T.unsafe(nil), Neo4j::Driver::Internal::Handlers::Pulln::BasicPullResponseHandler::State::Streaming)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/basic_pull_response_handler.rb#266
Neo4j::Driver::Internal::Handlers::Pulln::BasicPullResponseHandler::State::SUCCEEDED_STATE = T.let(T.unsafe(nil), Neo4j::Driver::Internal::Handlers::Pulln::BasicPullResponseHandler::State::Succeeded)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/basic_pull_response_handler.rb#178
class Neo4j::Driver::Internal::Handlers::Pulln::BasicPullResponseHandler::State::Streaming
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/basic_pull_response_handler.rb#204
  def cancel(context); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/basic_pull_response_handler.rb#189
  def on_failure(context, error); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/basic_pull_response_handler.rb#194
  def on_record(context, fields); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/basic_pull_response_handler.rb#179
  def on_success(context, metadata); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/basic_pull_response_handler.rb#199
  def request(context, n); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/basic_pull_response_handler.rb#242
class Neo4j::Driver::Internal::Handlers::Pulln::BasicPullResponseHandler::State::Succeeded
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/basic_pull_response_handler.rb#261
  def cancel(context); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/basic_pull_response_handler.rb#248
  def on_failure(context, error); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/basic_pull_response_handler.rb#253
  def on_record(context, _fields); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/basic_pull_response_handler.rb#243
  def on_success(context, metadata); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/basic_pull_response_handler.rb#257
  def request(context, _n); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/fetch_size_util.rb#5
class Neo4j::Driver::Internal::Handlers::Pulln::FetchSizeUtil
  class << self
    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/fetch_size_util.rb#9
    def assert_valid_fetch_size(size); end
  end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/fetch_size_util.rb#7
Neo4j::Driver::Internal::Handlers::Pulln::FetchSizeUtil::DEFAULT_FETCH_SIZE = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/pulln/fetch_size_util.rb#6
Neo4j::Driver::Internal::Handlers::Pulln::FetchSizeUtil::UNLIMITED_FETCH_SIZE = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/reset_response_handler.rb#4
class Neo4j::Driver::Internal::Handlers::ResetResponseHandler
  include ::Neo4j::Driver::Internal::Spi::ResponseHandler

  # @return [ResetResponseHandler] a new instance of ResetResponseHandler
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/reset_response_handler.rb#7
  def initialize(message_dispatcher, completion_future = T.unsafe(nil)); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/reset_response_handler.rb#16
  def on_failure(_error); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/reset_response_handler.rb#20
  def on_record(_fields); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/reset_response_handler.rb#12
  def on_success(_metadata = T.unsafe(nil)); end

  private

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/reset_response_handler.rb#24
  def reset_completed(_success); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/rollback_tx_response_handler.rb#4
class Neo4j::Driver::Internal::Handlers::RollbackTxResponseHandler
  include ::Neo4j::Driver::Internal::Spi::ResponseHandler

  # @return [RollbackTxResponseHandler] a new instance of RollbackTxResponseHandler
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/rollback_tx_response_handler.rb#7
  def initialize(result_holder); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/rollback_tx_response_handler.rb#15
  def on_failure(error); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/rollback_tx_response_handler.rb#19
  def on_record(fields); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/rollback_tx_response_handler.rb#11
  def on_success(_metadata); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/route_message_response_handler.rb#4
class Neo4j::Driver::Internal::Handlers::RouteMessageResponseHandler < ::Struct
  include ::Neo4j::Driver::Internal::Spi::ResponseHandler

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/route_message_response_handler.rb#11
  def on_failure(error); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/route_message_response_handler.rb#15
  def on_record(fields); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/route_message_response_handler.rb#7
  def on_success(metadata); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/routing_response_handler.rb#4
class Neo4j::Driver::Internal::Handlers::RoutingResponseHandler
  include ::Neo4j::Driver::Internal::Spi::ResponseHandler

  # @return [RoutingResponseHandler] a new instance of RoutingResponseHandler
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/routing_response_handler.rb#8
  def initialize(delegate, address, access_mode, error_handler); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/routing_response_handler.rb#6
  def can_manage_auto_read(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/routing_response_handler.rb#6
  def disable_auto_read_management(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/routing_response_handler.rb#15
  def on_failure(error); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/routing_response_handler.rb#6
  def on_record(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/routing_response_handler.rb#6
  def on_success(*_arg0, **_arg1, &_arg2); end

  private

  # @return [Boolean]
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/routing_response_handler.rb#63
  def failure_to_write?(e); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/routing_response_handler.rb#47
  def handled_client_exception(e); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/routing_response_handler.rb#22
  def handled_error(received_error); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/routing_response_handler.rb#38
  def handled_service_unavailable_exception(e); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/routing_response_handler.rb#43
  def handled_transient_exception(e); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/run_response_handler.rb#4
class Neo4j::Driver::Internal::Handlers::RunResponseHandler
  include ::Neo4j::Driver::Internal::Spi::ResponseHandler

  # @return [RunResponseHandler] a new instance of RunResponseHandler
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/run_response_handler.rb#8
  def initialize(metadata_extractor, connection, tx); end

  # Returns the value of attribute error.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/run_response_handler.rb#6
  def error; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/run_response_handler.rb#21
  def on_failure(error); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/run_response_handler.rb#32
  def on_record(_fields); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/run_response_handler.rb#15
  def on_success(metadata); end

  # Returns the value of attribute query_id.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/run_response_handler.rb#6
  def query_id; end

  # Returns the value of attribute query_keys.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/run_response_handler.rb#6
  def query_keys; end

  # Returns the value of attribute result_available_after.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/run_response_handler.rb#6
  def result_available_after; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/session_pull_response_completion_listener.rb#4
class Neo4j::Driver::Internal::Handlers::SessionPullResponseCompletionListener
  # @return [SessionPullResponseCompletionListener] a new instance of SessionPullResponseCompletionListener
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/session_pull_response_completion_listener.rb#5
  def initialize(connection, bookmark_holder); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/session_pull_response_completion_listener.rb#15
  def after_failure(error); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/session_pull_response_completion_listener.rb#10
  def after_success(metadata); end

  private

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/session_pull_response_completion_listener.rb#28
  def release_connection; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/transaction_pull_response_completion_listener.rb#4
class Neo4j::Driver::Internal::Handlers::TransactionPullResponseCompletionListener
  # @return [TransactionPullResponseCompletionListener] a new instance of TransactionPullResponseCompletionListener
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/transaction_pull_response_completion_listener.rb#5
  def initialize(tx); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/transaction_pull_response_completion_listener.rb#11
  def after_failure(error); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/handlers/transaction_pull_response_completion_listener.rb#9
  def after_success(_metadata); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/impersonation_util.rb#3
class Neo4j::Driver::Internal::ImpersonationUtil
  class << self
    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/impersonation_util.rb#6
    def ensure_impersonation_support(connection, impersonated_user); end

    # @return [Boolean]
    #
    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/impersonation_util.rb#16
    def supports_impersonation?(connection); end
  end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/impersonation_util.rb#4
Neo4j::Driver::Internal::ImpersonationUtil::IMPERSONATION_UNSUPPORTED_ERROR_MESSAGE = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_bookmark.rb#3
class Neo4j::Driver::Internal::InternalBookmark
  include ::Neo4j::Driver::Bookmark

  # @return [InternalBookmark] a new instance of InternalBookmark
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_bookmark.rb#8
  def initialize(*values); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_bookmark.rb#13
  def ==(other); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_bookmark.rb#6
  def empty?(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_bookmark.rb#13
  def eql?(other); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_bookmark.rb#6
  def hash(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_bookmark.rb#19
  def to_s; end

  # Returns the value of attribute values.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_bookmark.rb#5
  def values; end

  class << self
    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_bookmark.rb#24
    def empty; end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_bookmark.rb#28
    def from(*bookmarks); end

    def parse(*_arg0); end
  end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_bookmark.rb#11
Neo4j::Driver::Internal::InternalBookmark::EMPTY = T.let(T.unsafe(nil), Neo4j::Driver::Internal::InternalBookmark)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_database_name.rb#3
class Neo4j::Driver::Internal::InternalDatabaseName < ::Struct
  # @return [InternalDatabaseName] a new instance of InternalDatabaseName
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_database_name.rb#4
  def initialize(database_name: T.unsafe(nil), description: T.unsafe(nil)); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_driver.rb#3
class Neo4j::Driver::Internal::InternalDriver
  extend ::Neo4j::Driver::AutoClosable
  extend ::Neo4j::Driver::Synchronizable

  # @return [InternalDriver] a new instance of InternalDriver
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_driver.rb#12
  def initialize(security_plan, session_factory, metrics_provider, logger); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_driver.rb#24
  def async_session(**session_config); end

  # source://neo4j-ruby-driver//lib/neo4j/driver/synchronizable.rb#15
  def close(*args, **kwargs, &block); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_driver.rb#37
  def close_async; end

  # @return [Boolean]
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_driver.rb#28
  def encrypted?; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_driver.rb#8
  def metrics(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_driver.rb#8
  def metrics_enabled?(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute metrics_provider.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_driver.rb#6
  def metrics_provider; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_driver.rb#59
  def new_session(**config); end

  # source://neo4j-ruby-driver//lib/neo4j/driver/synchronizable.rb#15
  def session(*args, **kwargs, &block); end

  # Returns the value of attribute session_factory.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_driver.rb#6
  def session_factory; end

  # @return [Boolean]
  #
  # source://neo4j-ruby-driver//lib/neo4j/driver/synchronizable.rb#15
  def supports_multi_db?(*args, **kwargs, &block); end

  # @return [Boolean]
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_driver.rb#51
  def supports_multi_db_async?; end

  # source://neo4j-ruby-driver//lib/neo4j/driver/synchronizable.rb#15
  def verify_connectivity(*args, **kwargs, &block); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_driver.rb#43
  def verify_connectivity_async; end

  private

  # @raise [Exceptions::IllegalStateException]
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_driver.rb#69
  def assert_open!; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_entity.rb#3
class Neo4j::Driver::Internal::InternalEntity
  # @return [InternalEntity] a new instance of InternalEntity
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_entity.rb#8
  def initialize(id, properties); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_entity.rb#13
  def ==(other); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_entity.rb#6
  def [](*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_entity.rb#13
  def eql?(other); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_entity.rb#5
  def hash(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute id.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_entity.rb#4
  def id; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_entity.rb#6
  def key?(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_entity.rb#6
  def keys(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute properties.
  #
  # source://activegraph/11.5.0.beta.2-6d892820668cd8c6519bdc7202b32c22de0385d9/lib/active_graph/core/entity.rb#6
  def properties; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_entity.rb#6
  def size(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_entity.rb#6
  def to_h(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_entity.rb#6
  def values(*_arg0, **_arg1, &_arg2); end
end

# {@link Node} implementation that directly contains labels and properties.
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_node.rb#4
class Neo4j::Driver::Internal::InternalNode < ::Neo4j::Driver::Internal::InternalEntity
  # @return [InternalNode] a new instance of InternalNode
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_node.rb#7
  def initialize(id, *labels, **properties); end

  # @return [Boolean]
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_node.rb#12
  def label?(label); end

  # Returns the value of attribute labels.
  #
  # source://activegraph/11.5.0.beta.2-6d892820668cd8c6519bdc7202b32c22de0385d9/lib/active_graph/core/node.rb#10
  def labels; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_node.rb#16
  def to_s; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_pair.rb#3
class Neo4j::Driver::Internal::InternalPair < ::Struct
  class << self
    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_pair.rb#4
    def of(key, value); end
  end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_path.rb#3
class Neo4j::Driver::Internal::InternalPath < ::Array
  # @return [InternalPath] a new instance of InternalPath
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_path.rb#16
  def initialize(nodes, relationships); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_path.rb#30
  def end_node; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_path.rb#14
  def include?(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_path.rb#13
  def length(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute nodes.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_path.rb#4
  def nodes; end

  # Returns the value of attribute relationships.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_path.rb#4
  def relationships; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_path.rb#26
  def start_node; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_path.rb#22
  def to_s; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_path.rb#6
class Neo4j::Driver::Internal::InternalPath::Segment < ::Struct
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_path.rb#7
  def to_s; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_point2_d.rb#3
class Neo4j::Driver::Internal::InternalPoint2D < ::Struct
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_point2_d.rb#4
  def z; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_point3_d.rb#3
class Neo4j::Driver::Internal::InternalPoint3D < ::Struct; end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_record.rb#6
class Neo4j::Driver::Internal::InternalRecord
  # @return [InternalRecord] a new instance of InternalRecord
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_record.rb#11
  def initialize(keys, values); end

  # source://activegraph/11.5.0.beta.2-6d892820668cd8c6519bdc7202b32c22de0385d9/lib/active_graph/core/record.rb#14
  def [](key); end

  # source://activegraph/11.5.0.beta.2-6d892820668cd8c6519bdc7202b32c22de0385d9/lib/active_graph/core/record.rb#10
  def first; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_record.rb#9
  def key?(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute keys.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_record.rb#7
  def keys; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_record.rb#8
  def size(*_arg0, **_arg1, &_arg2); end

  # source://activegraph/11.5.0.beta.2-6d892820668cd8c6519bdc7202b32c22de0385d9/lib/active_graph/core/record.rb#18
  def to_h; end

  # Returns the value of attribute values.
  #
  # source://activegraph/11.5.0.beta.2-6d892820668cd8c6519bdc7202b32c22de0385d9/lib/active_graph/core/record.rb#6
  def values; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_relationship.rb#5
class Neo4j::Driver::Internal::InternalRelationship < ::Neo4j::Driver::Internal::InternalEntity
  # @return [InternalRelationship] a new instance of InternalRelationship
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_relationship.rb#9
  def initialize(id, start_node_id, end_node_id, type, **properties); end

  # Returns the value of attribute end_node_id.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_relationship.rb#6
  def end_node_id; end

  # Sets the attribute end_node_id
  #
  # @param value the value to set the attribute end_node_id to.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_relationship.rb#6
  def end_node_id=(_arg0); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_relationship.rb#16
  def start_and_end_node_ids=(start_node_id, end_node_id); end

  # Returns the value of attribute start_node_id.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_relationship.rb#6
  def start_node_id; end

  # Sets the attribute start_node_id
  #
  # @param value the value to set the attribute start_node_id to.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_relationship.rb#6
  def start_node_id=(_arg0); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_relationship.rb#21
  def to_s; end

  # Returns the value of attribute type.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_relationship.rb#7
  def type; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_result.rb#3
class Neo4j::Driver::Internal::InternalResult
  include ::Enumerable
  extend ::Neo4j::Driver::Synchronizable

  # @return [InternalResult] a new instance of InternalResult
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_result.rb#9
  def initialize(connection, cursor); end

  # source://neo4j-ruby-driver//lib/neo4j/driver/synchronizable.rb#15
  def consume(*args, **kwargs, &block); end

  # source://activegraph/11.5.0.beta.2-6d892820668cd8c6519bdc7202b32c22de0385d9/lib/active_graph/core/result.rb#14
  def each(&block); end

  # @return [Boolean]
  #
  # source://neo4j-ruby-driver//lib/neo4j/driver/synchronizable.rb#15
  def has_next?(*args, **kwargs, &block); end

  # source://activegraph/11.5.0.beta.2-6d892820668cd8c6519bdc7202b32c22de0385d9/lib/active_graph/core/result.rb#6
  def keys; end

  # source://neo4j-ruby-driver//lib/neo4j/driver/synchronizable.rb#15
  def next(*args, **kwargs, &block); end

  # source://neo4j-ruby-driver//lib/neo4j/driver/synchronizable.rb#15
  def peek(*args, **kwargs, &block); end

  # @raise [ClientException]
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_result.rb#38
  def remove; end

  # source://neo4j-ruby-driver//lib/neo4j/driver/synchronizable.rb#15
  def single(*args, **kwargs, &block); end

  private

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_result.rb#44
  def terminate_connection_on_thread_interrupt; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_session.rb#3
class Neo4j::Driver::Internal::InternalSession
  extend ::Neo4j::Driver::AutoClosable
  extend ::Neo4j::Driver::Synchronizable

  # @return [InternalSession] a new instance of InternalSession
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_session.rb#11
  def initialize(session); end

  # source://neo4j-ruby-driver//lib/neo4j/driver/synchronizable.rb#15
  def begin_transaction(*args, **kwargs, &block); end

  # source://neo4j-ruby-driver//lib/neo4j/driver/synchronizable.rb#15
  def close(*args, **kwargs, &block); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_session.rb#7
  def last_bookmark(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_session.rb#7
  def open?(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_session.rb#40
  def read_transaction(**config, &block); end

  # source://neo4j-ruby-driver//lib/neo4j/driver/synchronizable.rb#15
  def run(*args, **kwargs, &block); end

  # source://neo4j-ruby-driver//lib/neo4j/driver/synchronizable.rb#15
  def transaction(*args, **kwargs, &block); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_session.rb#44
  def write_transaction(**config, &block); end

  private

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_session.rb#65
  def private_begin_transaction(mode, **config); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_session.rb#72
  def terminate_connection_on_thread_interrupt(reason); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_transaction.rb#3
class Neo4j::Driver::Internal::InternalTransaction
  extend ::Neo4j::Driver::Synchronizable

  # @return [InternalTransaction] a new instance of InternalTransaction
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_transaction.rb#8
  def initialize(tx); end

  # source://neo4j-ruby-driver//lib/neo4j/driver/synchronizable.rb#15
  def close(*args, **kwargs, &block); end

  # source://neo4j-ruby-driver//lib/neo4j/driver/synchronizable.rb#15
  def commit(*args, **kwargs, &block); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_transaction.rb#6
  def open?(*_arg0, **_arg1, &_arg2); end

  # source://activegraph/11.5.0.beta.2-6d892820668cd8c6519bdc7202b32c22de0385d9/lib/active_graph/transaction.rb#3
  def rollback; end

  # source://neo4j-ruby-driver//lib/neo4j/driver/synchronizable.rb#15
  def run(*args, **kwargs, &block); end

  private

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/internal_transaction.rb#43
  def terminate_connection_on_thread_interrupt(reason); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver.rb#0
module Neo4j::Driver::Internal::Logging; end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/logging/channel_activity_logger.rb#4
class Neo4j::Driver::Internal::Logging::ChannelActivityLogger < ::Neo4j::Driver::Internal::Logging::ReformattedLogger
  # @return [ChannelActivityLogger] a new instance of ChannelActivityLogger
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/logging/channel_activity_logger.rb#5
  def initialize(channel, logger, owner); end

  private

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/logging/channel_activity_logger.rb#19
  def db_connection_id; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/logging/channel_activity_logger.rb#14
  def format_message(severity, datetime, progname, msg); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/logging/channel_activity_logger.rb#23
  def server_address; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/logging/channel_error_logger.rb#4
class Neo4j::Driver::Internal::Logging::ChannelErrorLogger < ::Neo4j::Driver::Internal::Logging::ChannelActivityLogger
  # @return [ChannelErrorLogger] a new instance of ChannelErrorLogger
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/logging/channel_error_logger.rb#7
  def initialize(channel, logger); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/logging/channel_error_logger.rb#11
  def debug(message, error); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/logging/channel_error_logger.rb#5
Neo4j::Driver::Internal::Logging::ChannelErrorLogger::DEBUG_MESSAGE_FORMAT = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/logging/prefixed_logger.rb#4
class Neo4j::Driver::Internal::Logging::PrefixedLogger < ::Neo4j::Driver::Internal::Logging::ReformattedLogger
  # @return [PrefixedLogger] a new instance of PrefixedLogger
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/logging/prefixed_logger.rb#5
  def initialize(message_prefix = T.unsafe(nil), delegate); end

  private

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/logging/prefixed_logger.rb#12
  def format_message(severity, datetime, progname, msg); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/logging/reformatted_logger.rb#4
class Neo4j::Driver::Internal::Logging::ReformattedLogger
  # @return [ReformattedLogger] a new instance of ReformattedLogger
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/logging/reformatted_logger.rb#7
  def initialize(delegate); end

  # source://activesupport/7.2.2.1/lib/active_support/delegation.rb#187
  def method_missing(method, *_arg1, **_arg2, &_arg3); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/logging/reformatted_logger.rb#11
  def trace(*arg); end

  private

  # source://activesupport/7.2.2.1/lib/active_support/delegation.rb#179
  def respond_to_missing?(name, include_private = T.unsafe(nil)); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver.rb#0
module Neo4j::Driver::Internal::Messaging; end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/abstract_message_writer.rb#4
class Neo4j::Driver::Internal::Messaging::AbstractMessageWriter
  # @return [AbstractMessageWriter] a new instance of AbstractMessageWriter
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/abstract_message_writer.rb#5
  def initialize(packer); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/abstract_message_writer.rb#10
  def write(msg); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/bolt_protocol.rb#4
module Neo4j::Driver::Internal::Messaging::BoltProtocol
  class << self
    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/bolt_protocol.rb#5
    def for_channel(channel); end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/bolt_protocol.rb#9
    def for_version(version); end
  end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/bolt_protocol_version.rb#4
class Neo4j::Driver::Internal::Messaging::BoltProtocolVersion < ::Struct
  include ::Comparable

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/bolt_protocol_version.rb#35
  def <=>(other); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/bolt_protocol_version.rb#13
  def to_int; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/bolt_protocol_version.rb#18
  def to_int_range(min_version); end

  # @return the version in format X.Y where X is the major version and Y is the minor version
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/bolt_protocol_version.rb#31
  def to_s; end

  class << self
    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/bolt_protocol_version.rb#7
    def from_raw_bytes(raw_version); end

    # @return [Boolean]
    #
    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/bolt_protocol_version.rb#40
    def http?(protocol_version); end
  end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver.rb#0
module Neo4j::Driver::Internal::Messaging::Common; end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_message_reader.rb#5
class Neo4j::Driver::Internal::Messaging::Common::CommonMessageReader
  # @return [CommonMessageReader] a new instance of CommonMessageReader
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_message_reader.rb#6
  def initialize(input); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_message_reader.rb#10
  def read(handler); end

  private

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_message_reader.rb#35
  def unpack_failure_message(output); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_message_reader.rb#39
  def unpack_ignored_message(output); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_message_reader.rb#43
  def unpack_record_message(output); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_message_reader.rb#30
  def unpack_success_message(output); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value.rb#5
module Neo4j::Driver::Internal::Messaging::Common::CommonValue
  include ::Neo4j::Driver::Internal::Packstream::PackStream::Common
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value.rb#7
Neo4j::Driver::Internal::Messaging::Common::CommonValue::DATE = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value.rb#8
Neo4j::Driver::Internal::Messaging::Common::CommonValue::DATE_STRUCT_SIZE = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value.rb#17
Neo4j::Driver::Internal::Messaging::Common::CommonValue::DATE_TIME_STRUCT_SIZE = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value.rb#16
Neo4j::Driver::Internal::Messaging::Common::CommonValue::DATE_TIME_WITH_ZONE_ID = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value.rb#15
Neo4j::Driver::Internal::Messaging::Common::CommonValue::DATE_TIME_WITH_ZONE_OFFSET = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value.rb#18
Neo4j::Driver::Internal::Messaging::Common::CommonValue::DURATION = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value.rb#19
Neo4j::Driver::Internal::Messaging::Common::CommonValue::DURATION_TIME_STRUCT_SIZE = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value.rb#25
Neo4j::Driver::Internal::Messaging::Common::CommonValue::EPOCH = T.let(T.unsafe(nil), Date)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value.rb#13
Neo4j::Driver::Internal::Messaging::Common::CommonValue::LOCAL_DATE_TIME = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value.rb#14
Neo4j::Driver::Internal::Messaging::Common::CommonValue::LOCAL_DATE_TIME_STRUCT_SIZE = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value.rb#11
Neo4j::Driver::Internal::Messaging::Common::CommonValue::LOCAL_TIME = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value.rb#12
Neo4j::Driver::Internal::Messaging::Common::CommonValue::LOCAL_TIME_STRUCT_SIZE = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value.rb#26
Neo4j::Driver::Internal::Messaging::Common::CommonValue::NANO_FACTOR = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value.rb#21
Neo4j::Driver::Internal::Messaging::Common::CommonValue::POINT_2D_STRUCT_SIZE = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value.rb#20
Neo4j::Driver::Internal::Messaging::Common::CommonValue::POINT_2D_STRUCT_TYPE = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value.rb#23
Neo4j::Driver::Internal::Messaging::Common::CommonValue::POINT_3D_STRUCT_SIZE = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value.rb#22
Neo4j::Driver::Internal::Messaging::Common::CommonValue::POINT_3D_STRUCT_TYPE = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value.rb#9
Neo4j::Driver::Internal::Messaging::Common::CommonValue::TIME = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value.rb#10
Neo4j::Driver::Internal::Messaging::Common::CommonValue::TIME_STRUCT_SIZE = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value_packer.rb#5
module Neo4j::Driver::Internal::Messaging::Common::CommonValuePacker
  include ::Neo4j::Driver::Internal::Packstream::PackStream::Common
  include ::Neo4j::Driver::Internal::Messaging::Common::CommonValue

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value_packer.rb#8
  def pack(value); end

  private

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value_packer.rb#33
  def pack_date(local_date); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value_packer.rb#69
  def pack_date_time(time); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value_packer.rb#63
  def pack_date_time_with_zone_id(time); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value_packer.rb#74
  def pack_date_time_with_zone_offset(time); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value_packer.rb#80
  def pack_duration(duration); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value_packer.rb#57
  def pack_local_date_time(local_date_time); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value_packer.rb#52
  def pack_local_time(local_time); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value_packer.rb#48
  def pack_nano_of_day(local_time); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value_packer.rb#85
  def pack_point(point); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value_packer.rb#38
  def pack_time(offset_time); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value_packer.rb#44
  def pack_utc_offset(time); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value_unpacker.rb#5
module Neo4j::Driver::Internal::Messaging::Common::CommonValueUnpacker
  include ::Neo4j::Driver::Internal::Packstream::PackStream::Common
  include ::Neo4j::Driver::Internal::Messaging::Common::CommonValue

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value_unpacker.rb#21
  def unpack; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value_unpacker.rb#17
  def unpack_array(size); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value_unpacker.rb#13
  def unpack_map(size); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value_unpacker.rb#77
  def unpack_struct(size, type); end

  private

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value_unpacker.rb#173
  def ensure_correct_struct_signature(struct_name, expected, actual); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value_unpacker.rb#164
  def ensure_correct_struct_size(type_constructor, expected, actual); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value_unpacker.rb#184
  def time(nano_of_day_local, offset_seconds = T.unsafe(nil)); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value_unpacker.rb#180
  def unpack_date; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value_unpacker.rb#211
  def unpack_date_time_with_zone_id; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value_unpacker.rb#201
  def unpack_date_time_with_zone_offset; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value_unpacker.rb#216
  def unpack_duration; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value_unpacker.rb#197
  def unpack_local_date_time; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value_unpacker.rb#193
  def unpack_local_time; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value_unpacker.rb#133
  def unpack_node; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value_unpacker.rb#137
  def unpack_path; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value_unpacker.rb#223
  def unpack_point2_d; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value_unpacker.rb#227
  def unpack_point3_d; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value_unpacker.rb#125
  def unpack_relationship; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value_unpacker.rb#189
  def unpack_time; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value_unpacker.rb#129
  def unpack_unbound_relationship; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value_unpacker.rb#157
  def update(rel, prev_node, node, inversed); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value_unpacker.rb#7
Neo4j::Driver::Internal::Messaging::Common::CommonValueUnpacker::NODE = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value_unpacker.rb#11
Neo4j::Driver::Internal::Messaging::Common::CommonValueUnpacker::NODE_FIELDS = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value_unpacker.rb#10
Neo4j::Driver::Internal::Messaging::Common::CommonValueUnpacker::PATH = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value_unpacker.rb#8
Neo4j::Driver::Internal::Messaging::Common::CommonValueUnpacker::RELATIONSHIP = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/common/common_value_unpacker.rb#9
Neo4j::Driver::Internal::Messaging::Common::CommonValueUnpacker::UNBOUND_RELATIONSHIP = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//ruby/neo4j/driver.rb#0
module Neo4j::Driver::Internal::Messaging::Encode; end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/encode/begin_message_encoder.rb#5
class Neo4j::Driver::Internal::Messaging::Encode::BeginMessageEncoder
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/encode/begin_message_encoder.rb#6
  def encode(message, packer); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/encode/commit_message_encoder.rb#5
class Neo4j::Driver::Internal::Messaging::Encode::CommitMessageEncoder
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/encode/commit_message_encoder.rb#6
  def encode(message, packer); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/encode/discard_all_message_encoder.rb#5
class Neo4j::Driver::Internal::Messaging::Encode::DiscardAllMessageEncoder
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/encode/discard_all_message_encoder.rb#6
  def encode(message, packer); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/encode/discard_message_encoder.rb#5
class Neo4j::Driver::Internal::Messaging::Encode::DiscardMessageEncoder
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/encode/discard_message_encoder.rb#6
  def encode(message, packer); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/encode/goodbye_message_encoder.rb#5
class Neo4j::Driver::Internal::Messaging::Encode::GoodbyeMessageEncoder
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/encode/goodbye_message_encoder.rb#6
  def encode(message, packer); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/encode/hello_message_encoder.rb#5
class Neo4j::Driver::Internal::Messaging::Encode::HelloMessageEncoder
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/encode/hello_message_encoder.rb#6
  def encode(message, packer); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/encode/init_message_encoder.rb#5
class Neo4j::Driver::Internal::Messaging::Encode::InitMessageEncoder
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/encode/init_message_encoder.rb#6
  def encode(message, packer); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/encode/pull_all_message_encoder.rb#5
class Neo4j::Driver::Internal::Messaging::Encode::PullAllMessageEncoder
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/encode/pull_all_message_encoder.rb#6
  def encode(message, packer); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/encode/pull_message_encoder.rb#5
class Neo4j::Driver::Internal::Messaging::Encode::PullMessageEncoder
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/encode/pull_message_encoder.rb#6
  def encode(message, packer); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/encode/reset_message_encoder.rb#5
class Neo4j::Driver::Internal::Messaging::Encode::ResetMessageEncoder
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/encode/reset_message_encoder.rb#6
  def encode(message, packer); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/encode/rollback_message_encoder.rb#5
class Neo4j::Driver::Internal::Messaging::Encode::RollbackMessageEncoder
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/encode/rollback_message_encoder.rb#6
  def encode(message, packer); end
end

# Encodes the ROUTE message to the stream
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/encode/route_message_encoder.rb#6
class Neo4j::Driver::Internal::Messaging::Encode::RouteMessageEncoder
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/encode/route_message_encoder.rb#7
  def encode(message, packer); end

  private

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/encode/route_message_encoder.rb#17
  def option(message); end
end

# Encodes the ROUTE message to the stream
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/encode/route_v44_message_encoder.rb#6
class Neo4j::Driver::Internal::Messaging::Encode::RouteV44MessageEncoder < ::Neo4j::Driver::Internal::Messaging::Encode::RouteMessageEncoder
  private

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/encode/route_v44_message_encoder.rb#9
  def option(message); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/encode/run_message_encoder.rb#5
class Neo4j::Driver::Internal::Messaging::Encode::RunMessageEncoder
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/encode/run_message_encoder.rb#6
  def encode(message, packer); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/encode/run_with_metadata_message_encoder.rb#5
class Neo4j::Driver::Internal::Messaging::Encode::RunWithMetadataMessageEncoder
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/encode/run_with_metadata_message_encoder.rb#6
  def encode(message, packer); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver.rb#0
module Neo4j::Driver::Internal::Messaging::Request; end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/abstract_streaming_message.rb#5
class Neo4j::Driver::Internal::Messaging::Request::AbstractStreamingMessage < ::Struct
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/abstract_streaming_message.rb#8
  def metadata; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/abstract_streaming_message.rb#12
  def to_s; end

  protected

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/abstract_streaming_message.rb#18
  def name; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/abstract_streaming_message.rb#6
Neo4j::Driver::Internal::Messaging::Request::AbstractStreamingMessage::STREAM_LIMIT_UNLIMITED = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/begin_message.rb#5
class Neo4j::Driver::Internal::Messaging::Request::BeginMessage < ::Neo4j::Driver::Internal::Messaging::Request::MessageWithMetadata
  # @return [BeginMessage] a new instance of BeginMessage
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/begin_message.rb#8
  def initialize(bookmark, config, database_name, mode, impersonated_user); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/begin_message.rb#14
  def signature; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/begin_message.rb#18
  def to_s; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/begin_message.rb#6
Neo4j::Driver::Internal::Messaging::Request::BeginMessage::SIGNATURE = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/commit_message.rb#5
class Neo4j::Driver::Internal::Messaging::Request::CommitMessage
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/commit_message.rb#9
  def signature; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/commit_message.rb#13
  def to_s; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/commit_message.rb#7
Neo4j::Driver::Internal::Messaging::Request::CommitMessage::COMMIT = T.let(T.unsafe(nil), Neo4j::Driver::Internal::Messaging::Request::CommitMessage)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/commit_message.rb#6
Neo4j::Driver::Internal::Messaging::Request::CommitMessage::SIGNATURE = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/discard_all_message.rb#5
class Neo4j::Driver::Internal::Messaging::Request::DiscardAllMessage
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/discard_all_message.rb#9
  def signature; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/discard_all_message.rb#13
  def to_s; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/discard_all_message.rb#7
Neo4j::Driver::Internal::Messaging::Request::DiscardAllMessage::DISCARD_ALL = T.let(T.unsafe(nil), Neo4j::Driver::Internal::Messaging::Request::DiscardAllMessage)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/discard_all_message.rb#6
Neo4j::Driver::Internal::Messaging::Request::DiscardAllMessage::SIGNATURE = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/discard_message.rb#5
class Neo4j::Driver::Internal::Messaging::Request::DiscardMessage < ::Neo4j::Driver::Internal::Messaging::Request::AbstractStreamingMessage
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/discard_message.rb#12
  def name; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/discard_message.rb#16
  def signature; end

  class << self
    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/discard_message.rb#8
    def new_discard_all_message(id); end
  end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/discard_message.rb#6
Neo4j::Driver::Internal::Messaging::Request::DiscardMessage::SIGNATURE = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/goodbye_message.rb#5
class Neo4j::Driver::Internal::Messaging::Request::GoodbyeMessage
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/goodbye_message.rb#9
  def signature; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/goodbye_message.rb#13
  def to_s; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/goodbye_message.rb#7
Neo4j::Driver::Internal::Messaging::Request::GoodbyeMessage::GOODBYE = T.let(T.unsafe(nil), Neo4j::Driver::Internal::Messaging::Request::GoodbyeMessage)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/goodbye_message.rb#6
Neo4j::Driver::Internal::Messaging::Request::GoodbyeMessage::SIGNATURE = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/hello_message.rb#5
class Neo4j::Driver::Internal::Messaging::Request::HelloMessage < ::Neo4j::Driver::Internal::Messaging::Request::MessageWithMetadata
  # @return [HelloMessage] a new instance of HelloMessage
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/hello_message.rb#10
  def initialize(user_agent, auth_token, routing_context); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/hello_message.rb#14
  def to_s; end

  private

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/hello_message.rb#21
  def build_metadata(user_agent, auth_token, routing_context); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/hello_message.rb#8
Neo4j::Driver::Internal::Messaging::Request::HelloMessage::ROUTING_CONTEXT_METADATA_KEY = T.let(T.unsafe(nil), Symbol)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/hello_message.rb#6
Neo4j::Driver::Internal::Messaging::Request::HelloMessage::SIGNATURE = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/hello_message.rb#7
Neo4j::Driver::Internal::Messaging::Request::HelloMessage::USER_AGENT_METADATA_KEY = T.let(T.unsafe(nil), Symbol)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/init_message.rb#5
class Neo4j::Driver::Internal::Messaging::Request::InitMessage < ::Struct
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/init_message.rb#8
  def signature; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/init_message.rb#12
  def to_s; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/init_message.rb#6
Neo4j::Driver::Internal::Messaging::Request::InitMessage::SIGNATURE = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/message_with_metadata.rb#5
class Neo4j::Driver::Internal::Messaging::Request::MessageWithMetadata < ::Struct; end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/multi_database_util.rb#5
class Neo4j::Driver::Internal::Messaging::Request::MultiDatabaseUtil
  class << self
    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/multi_database_util.rb#7
    def assert_empty_database_name(database_name, bolt_version); end

    # @return [Boolean]
    #
    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/multi_database_util.rb#13
    def supports_multi_database?(connection); end

    # @return [Boolean]
    #
    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/multi_database_util.rb#18
    def supports_route_message?(connection); end
  end
end

# PULL_ALL request message
# <p>
# Sent by clients to pull the entirety of the remaining stream down.
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/pull_all_message.rb#8
class Neo4j::Driver::Internal::Messaging::Request::PullAllMessage
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/pull_all_message.rb#12
  def signature; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/pull_all_message.rb#16
  def to_s; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/pull_all_message.rb#10
Neo4j::Driver::Internal::Messaging::Request::PullAllMessage::PULL_ALL = T.let(T.unsafe(nil), Neo4j::Driver::Internal::Messaging::Request::PullAllMessage)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/pull_all_message.rb#9
Neo4j::Driver::Internal::Messaging::Request::PullAllMessage::SIGNATURE = T.let(T.unsafe(nil), Integer)

# PULL request message
# <p>
# Sent by clients to pull the entirety of the remaining stream down.
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/pull_message.rb#8
class Neo4j::Driver::Internal::Messaging::Request::PullMessage < ::Neo4j::Driver::Internal::Messaging::Request::AbstractStreamingMessage
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/pull_message.rb#11
  def name; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/pull_message.rb#15
  def signature; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/pull_message.rb#9
Neo4j::Driver::Internal::Messaging::Request::PullMessage::SIGNATURE = T.let(T.unsafe(nil), Integer)

# RESET request message
# <p>
# Sent by clients to reset a session to a clean state - closing any open transaction or result streams.
# This also acknowledges receipt of failures sent by the server. This is required to
# allow optimistic sending of multiple messages before responses have been received - pipelining.
# <p>
# When something goes wrong, we want the server to stop processing our already sent messages,
# but the server cannot tell the difference between what was sent before and after we saw the
# error.
# <p>
# This message acts as a barrier after an error, informing the server that we've seen the error
# message, and that messages that follow this one are safe to execute.
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/reset_message.rb#17
class Neo4j::Driver::Internal::Messaging::Request::ResetMessage
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/reset_message.rb#25
  def signature; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/reset_message.rb#21
  def to_s; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/reset_message.rb#19
Neo4j::Driver::Internal::Messaging::Request::ResetMessage::RESET = T.let(T.unsafe(nil), Neo4j::Driver::Internal::Messaging::Request::ResetMessage)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/reset_message.rb#18
Neo4j::Driver::Internal::Messaging::Request::ResetMessage::SIGNATURE = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/rollback_message.rb#5
class Neo4j::Driver::Internal::Messaging::Request::RollbackMessage
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/rollback_message.rb#9
  def signature; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/rollback_message.rb#13
  def to_s; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/rollback_message.rb#7
Neo4j::Driver::Internal::Messaging::Request::RollbackMessage::ROLLBACK = T.let(T.unsafe(nil), Neo4j::Driver::Internal::Messaging::Request::RollbackMessage)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/rollback_message.rb#6
Neo4j::Driver::Internal::Messaging::Request::RollbackMessage::SIGNATURE = T.let(T.unsafe(nil), Integer)

# From the application point of view it is not interesting to know about the role a member plays in the cluster. Instead, the application needs to know which
# instance can provide the wanted service.
# <p>
# This message is used to fetch this routing information.
#
# @param routingContext The routing context used to define the routing table. Multi-datacenter deployments is one of its use cases.
# @param bookmark The bookmark used when getting the routing table.
# @param databaseName The name of the database to get the routing table for.
# @param impersonatedUser The name of the impersonated user to get the routing table for, should be {@code null} for non-impersonated requests
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/route_message.rb#14
class Neo4j::Driver::Internal::Messaging::Request::RouteMessage < ::Struct
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/route_message.rb#17
  def signature; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/route_message.rb#21
  def to_s; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/route_message.rb#15
Neo4j::Driver::Internal::Messaging::Request::RouteMessage::SIGNATURE = T.let(T.unsafe(nil), Integer)

# RUN request message
# <p>
# Sent by clients to start a new Tank job for a given query and
# parameter set.
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/run_message.rb#9
class Neo4j::Driver::Internal::Messaging::Request::RunMessage < ::Struct
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/run_message.rb#12
  def signature; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/run_message.rb#16
  def to_s; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/run_message.rb#10
Neo4j::Driver::Internal::Messaging::Request::RunMessage::SIGNATURE = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/run_with_metadata_message.rb#5
class Neo4j::Driver::Internal::Messaging::Request::RunWithMetadataMessage < ::Neo4j::Driver::Internal::Messaging::Request::MessageWithMetadata
  # @return [RunWithMetadataMessage] a new instance of RunWithMetadataMessage
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/run_with_metadata_message.rb#22
  def initialize(query, parameters, metadata); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/run_with_metadata_message.rb#32
  def ==(other); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/run_with_metadata_message.rb#32
  def eql?(other); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/run_with_metadata_message.rb#38
  def hash; end

  # Returns the value of attribute parameters.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/run_with_metadata_message.rb#7
  def parameters; end

  # Returns the value of attribute query.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/run_with_metadata_message.rb#7
  def query; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/run_with_metadata_message.rb#28
  def signature; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/run_with_metadata_message.rb#42
  def to_s; end

  class << self
    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/run_with_metadata_message.rb#10
    def auto_commit_tx_run_message(query, config, database_name, mode, bookmark, impersonated_user); end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/run_with_metadata_message.rb#17
    def unmanaged_tx_run_message(query); end
  end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/run_with_metadata_message.rb#6
Neo4j::Driver::Internal::Messaging::Request::RunWithMetadataMessage::SIGNATURE = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/transaction_metadata_builder.rb#5
class Neo4j::Driver::Internal::Messaging::Request::TransactionMetadataBuilder
  class << self
    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/transaction_metadata_builder.rb#9
    def build_metadata(timeout:, tx_metadata:, mode:, bookmark:, impersonated_user:, database_name: T.unsafe(nil)); end
  end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/request/transaction_metadata_builder.rb#6
Neo4j::Driver::Internal::Messaging::Request::TransactionMetadataBuilder::MODE_READ_VALUE = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//ruby/neo4j/driver.rb#0
module Neo4j::Driver::Internal::Messaging::Response; end

# FAILURE response message
# <p>
# Sent by the server to signal a failed operation.
# Terminates response sequence.
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/response/failure_message.rb#9
class Neo4j::Driver::Internal::Messaging::Response::FailureMessage
  # @return [FailureMessage] a new instance of FailureMessage
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/response/failure_message.rb#14
  def initialize(code, message); end

  # Returns the value of attribute code.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/response/failure_message.rb#12
  def code; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/response/failure_message.rb#23
  def equals(object); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/response/failure_message.rb#31
  def hash_code; end

  # Returns the value of attribute message.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/response/failure_message.rb#12
  def message; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/response/failure_message.rb#19
  def to_s; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/response/failure_message.rb#10
Neo4j::Driver::Internal::Messaging::Response::FailureMessage::SIGNATURE = T.let(T.unsafe(nil), Integer)

# <p>
# Sent by the server to signal that an operation has been ignored.
# Terminates response sequence.
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/response/ignored_message.rb#10
class Neo4j::Driver::Internal::Messaging::Response::IgnoredMessage
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/response/ignored_message.rb#18
  def equals(obj); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/response/ignored_message.rb#22
  def hash_code; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/response/ignored_message.rb#14
  def to_s; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/response/ignored_message.rb#12
Neo4j::Driver::Internal::Messaging::Response::IgnoredMessage::IGNORED = T.let(T.unsafe(nil), Neo4j::Driver::Internal::Messaging::Response::IgnoredMessage)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/response/ignored_message.rb#11
Neo4j::Driver::Internal::Messaging::Response::IgnoredMessage::SIGNATURE = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/response/record_message.rb#5
class Neo4j::Driver::Internal::Messaging::Response::RecordMessage
  # @return [RecordMessage] a new instance of RecordMessage
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/response/record_message.rb#10
  def initialize(fields); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/response/record_message.rb#18
  def equals(object); end

  # Returns the value of attribute fields.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/response/record_message.rb#8
  def fields; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/response/record_message.rb#26
  def hash_code; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/response/record_message.rb#14
  def to_s; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/response/record_message.rb#6
Neo4j::Driver::Internal::Messaging::Response::RecordMessage::SIGNATURE = T.let(T.unsafe(nil), Integer)

# <p>
# Sent by the server to signal a successful operation.
# Terminates response sequence.
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/response/success_message.rb#10
class Neo4j::Driver::Internal::Messaging::Response::SuccessMessage
  # @return [SuccessMessage] a new instance of SuccessMessage
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/response/success_message.rb#15
  def initialize(metadata); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/response/success_message.rb#23
  def equals(obj); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/response/success_message.rb#27
  def hash_code; end

  # Returns the value of attribute metadata.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/response/success_message.rb#13
  def metadata; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/response/success_message.rb#19
  def to_s; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/response/success_message.rb#11
Neo4j::Driver::Internal::Messaging::Response::SuccessMessage::SIGNATURE = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver.rb#0
module Neo4j::Driver::Internal::Messaging::V3; end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/v3/bolt_protocol_v3.rb#5
class Neo4j::Driver::Internal::Messaging::V3::BoltProtocolV3
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/v3/bolt_protocol_v3.rb#33
  def begin_transaction(connection, bookmark, config); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/v3/bolt_protocol_v3.rb#64
  def build_result_cursor_factory(connection, query, bookmark_holder, tx, run_message, ignored); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/v3/bolt_protocol_v3.rb#39
  def commit_transaction(connection); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/v3/bolt_protocol_v3.rb#10
  def create_message_format; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/v3/bolt_protocol_v3.rb#14
  def initialize_channel(channel, user_agent, auth_token, routing_context); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/v3/bolt_protocol_v3.rb#23
  def prepare_to_close_channel(channel); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/v3/bolt_protocol_v3.rb#45
  def rollback_transaction(connection); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/v3/bolt_protocol_v3.rb#51
  def run_in_auto_commit_transaction(connection, query, bookmark_holder, config, fetch_size); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/v3/bolt_protocol_v3.rb#59
  def run_in_unmanaged_transaction(connection, query, tx, fetch_size); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/v3/bolt_protocol_v3.rb#71
  def verify_database_name_before_transaction(database_name); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/v3/bolt_protocol_v3.rb#75
  def version; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/v3/bolt_protocol_v3.rb#7
Neo4j::Driver::Internal::Messaging::V3::BoltProtocolV3::INSTANCE = T.let(T.unsafe(nil), Neo4j::Driver::Internal::Messaging::V3::BoltProtocolV3)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/v3/bolt_protocol_v3.rb#8
Neo4j::Driver::Internal::Messaging::V3::BoltProtocolV3::METADATA_EXTRACTOR = T.let(T.unsafe(nil), Neo4j::Driver::Internal::Util::MetadataExtractor)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/v3/bolt_protocol_v3.rb#6
Neo4j::Driver::Internal::Messaging::V3::BoltProtocolV3::VERSION = T.let(T.unsafe(nil), Neo4j::Driver::Internal::Messaging::BoltProtocolVersion)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/v3/message_format_v3.rb#5
class Neo4j::Driver::Internal::Messaging::V3::MessageFormatV3
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/v3/message_format_v3.rb#10
  def new_reader(input); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/v3/message_format_v3.rb#6
  def new_writer(output); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/v3/message_writer_v3.rb#5
class Neo4j::Driver::Internal::Messaging::V3::MessageWriterV3 < ::Neo4j::Driver::Internal::Messaging::AbstractMessageWriter
  private

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/v3/message_writer_v3.rb#17
  def build_encoders; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/v3/message_writer_v3.rb#6
Neo4j::Driver::Internal::Messaging::V3::MessageWriterV3::COMMON_ENCODERS = T.let(T.unsafe(nil), Hash)

# source://neo4j-ruby-driver//ruby/neo4j/driver.rb#0
module Neo4j::Driver::Internal::Messaging::V4; end

# source://neo4j-ruby-driver//ruby/neo4j/driver.rb#0
module Neo4j::Driver::Internal::Messaging::V41; end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/v41/bolt_protocol_v41.rb#5
class Neo4j::Driver::Internal::Messaging::V41::BoltProtocolV41 < ::Neo4j::Driver::Internal::Messaging::V4::BoltProtocolV4
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/v41/bolt_protocol_v41.rb#13
  def build_result_cursor_factory(connection, query, bookmark_holder, tx, run_message, fetch_size); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/v41/bolt_protocol_v41.rb#9
  def create_message_format; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/v41/bolt_protocol_v41.rb#7
Neo4j::Driver::Internal::Messaging::V41::BoltProtocolV41::INSTANCE = T.let(T.unsafe(nil), Neo4j::Driver::Internal::Messaging::V41::BoltProtocolV41)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/v41/bolt_protocol_v41.rb#6
Neo4j::Driver::Internal::Messaging::V41::BoltProtocolV41::VERSION = T.let(T.unsafe(nil), Neo4j::Driver::Internal::Messaging::BoltProtocolVersion)

# source://neo4j-ruby-driver//ruby/neo4j/driver.rb#0
module Neo4j::Driver::Internal::Messaging::V42; end

# Bolt V4.2 is identical to V4.1
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/v42/bolt_protocol_v42.rb#6
class Neo4j::Driver::Internal::Messaging::V42::BoltProtocolV42 < ::Neo4j::Driver::Internal::Messaging::V41::BoltProtocolV41; end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/v42/bolt_protocol_v42.rb#8
Neo4j::Driver::Internal::Messaging::V42::BoltProtocolV42::INSTANCE = T.let(T.unsafe(nil), Neo4j::Driver::Internal::Messaging::V42::BoltProtocolV42)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/v42/bolt_protocol_v42.rb#7
Neo4j::Driver::Internal::Messaging::V42::BoltProtocolV42::VERSION = T.let(T.unsafe(nil), Neo4j::Driver::Internal::Messaging::BoltProtocolVersion)

# source://neo4j-ruby-driver//ruby/neo4j/driver.rb#0
module Neo4j::Driver::Internal::Messaging::V43; end

# The version 4.3 use most of the 4.2 behaviours, but it extends it with new messages such as ROUTE
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/v43/bolt_protocol_v43.rb#8
class Neo4j::Driver::Internal::Messaging::V43::BoltProtocolV43 < ::Neo4j::Driver::Internal::Messaging::V42::BoltProtocolV42
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/v43/bolt_protocol_v43.rb#12
  def create_message_format; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/v43/bolt_protocol_v43.rb#10
Neo4j::Driver::Internal::Messaging::V43::BoltProtocolV43::INSTANCE = T.let(T.unsafe(nil), Neo4j::Driver::Internal::Messaging::V43::BoltProtocolV43)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/v43/bolt_protocol_v43.rb#9
Neo4j::Driver::Internal::Messaging::V43::BoltProtocolV43::VERSION = T.let(T.unsafe(nil), Neo4j::Driver::Internal::Messaging::BoltProtocolVersion)

# Bolt message format v4.3
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/v43/message_format_v43.rb#6
class Neo4j::Driver::Internal::Messaging::V43::MessageFormatV43
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/v43/message_format_v43.rb#11
  def new_reader(input); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/v43/message_format_v43.rb#7
  def new_writer(output); end
end

# new messages such as ROUTE
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/v43/message_writer_v43.rb#10
class Neo4j::Driver::Internal::Messaging::V43::MessageWriterV43 < ::Neo4j::Driver::Internal::Messaging::V4::MessageWriterV4
  private

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/v43/message_writer_v43.rb#13
  def build_encoders; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver.rb#0
module Neo4j::Driver::Internal::Messaging::V44; end

# Definition of the Bolt Protocol 4.4
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/v44/bolt_protocol_v44.rb#6
class Neo4j::Driver::Internal::Messaging::V44::BoltProtocolV44 < ::Neo4j::Driver::Internal::Messaging::V43::BoltProtocolV43
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/v44/bolt_protocol_v44.rb#10
  def create_message_format; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/v44/bolt_protocol_v44.rb#8
Neo4j::Driver::Internal::Messaging::V44::BoltProtocolV44::INSTANCE = T.let(T.unsafe(nil), Neo4j::Driver::Internal::Messaging::V44::BoltProtocolV44)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/v44/bolt_protocol_v44.rb#7
Neo4j::Driver::Internal::Messaging::V44::BoltProtocolV44::VERSION = T.let(T.unsafe(nil), Neo4j::Driver::Internal::Messaging::BoltProtocolVersion)

# Bolt message format v4.4
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/v44/message_format_v44.rb#6
class Neo4j::Driver::Internal::Messaging::V44::MessageFormatV44
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/v44/message_format_v44.rb#11
  def new_reader(input); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/v44/message_format_v44.rb#7
  def new_writer(output); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/v44/message_writer_v44.rb#5
class Neo4j::Driver::Internal::Messaging::V44::MessageWriterV44 < ::Neo4j::Driver::Internal::Messaging::V4::MessageWriterV4
  private

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/v44/message_writer_v44.rb#8
  def build_encoders; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/v4/bolt_protocol_v4.rb#5
class Neo4j::Driver::Internal::Messaging::V4::BoltProtocolV4 < ::Neo4j::Driver::Internal::Messaging::V3::BoltProtocolV3
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/v4/bolt_protocol_v4.rb#13
  def build_result_cursor_factory(connection, query, bookmark_holder, tx, run_message, fetch_size); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/v4/bolt_protocol_v4.rb#9
  def create_message_format; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/v4/bolt_protocol_v4.rb#22
  def verify_database_name_before_transaction(_database_name); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/v4/bolt_protocol_v4.rb#7
Neo4j::Driver::Internal::Messaging::V4::BoltProtocolV4::INSTANCE = T.let(T.unsafe(nil), Neo4j::Driver::Internal::Messaging::V4::BoltProtocolV4)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/v4/bolt_protocol_v4.rb#6
Neo4j::Driver::Internal::Messaging::V4::BoltProtocolV4::VERSION = T.let(T.unsafe(nil), Neo4j::Driver::Internal::Messaging::BoltProtocolVersion)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/v4/message_format_v4.rb#5
class Neo4j::Driver::Internal::Messaging::V4::MessageFormatV4
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/v4/message_format_v4.rb#10
  def new_reader(input); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/v4/message_format_v4.rb#6
  def new_writer(output); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/v4/message_writer_v4.rb#5
class Neo4j::Driver::Internal::Messaging::V4::MessageWriterV4 < ::Neo4j::Driver::Internal::Messaging::V3::MessageWriterV3
  private

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/messaging/v4/message_writer_v4.rb#8
  def build_encoders; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver.rb#0
module Neo4j::Driver::Internal::Metrics; end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/connection_pool_metrics_listener.rb#4
module Neo4j::Driver::Internal::Metrics::ConnectionPoolMetricsListener; end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/connection_pool_metrics_listener.rb#5
Neo4j::Driver::Internal::Metrics::ConnectionPoolMetricsListener::DEV_NULL_POOL_METRICS_LISTENER = T.let(T.unsafe(nil), T.untyped)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/internal_abstract_metrics.rb#4
class Neo4j::Driver::Internal::Metrics::InternalAbstractMetrics; end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/internal_abstract_metrics.rb#5
Neo4j::Driver::Internal::Metrics::InternalAbstractMetrics::DEV_NULL_METRICS = T.let(T.unsafe(nil), T.untyped)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/internal_connection_pool_metrics.rb#4
class Neo4j::Driver::Internal::Metrics::InternalConnectionPoolMetrics
  # @return [InternalConnectionPoolMetrics] a new instance of InternalConnectionPoolMetrics
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/internal_connection_pool_metrics.rb#7
  def initialize(pool_id, address, pool); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/internal_connection_pool_metrics.rb#96
  def acquired; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/internal_connection_pool_metrics.rb#96
  def acquiring; end

  # Returns the value of attribute address.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/internal_connection_pool_metrics.rb#5
  def address; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/internal_connection_pool_metrics.rb#65
  def after_acquired_or_created(acquire_event); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/internal_connection_pool_metrics.rb#61
  def after_acquiring_or_creating; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/internal_connection_pool_metrics.rb#52
  def after_closed; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/internal_connection_pool_metrics.rb#44
  def after_created(conn_event); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/internal_connection_pool_metrics.rb#39
  def after_failed_to_create; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/internal_connection_pool_metrics.rb#71
  def after_timed_out_to_acquire_or_create; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/internal_connection_pool_metrics.rb#56
  def before_acquiring_or_creating(acquire_event); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/internal_connection_pool_metrics.rb#34
  def before_creating(conn_event); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/internal_connection_pool_metrics.rb#96
  def closed; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/internal_connection_pool_metrics.rb#96
  def created; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/internal_connection_pool_metrics.rb#96
  def creating; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/internal_connection_pool_metrics.rb#96
  def failed_to_create; end

  # Returns the value of attribute id.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/internal_connection_pool_metrics.rb#5
  def id; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/internal_connection_pool_metrics.rb#90
  def idle; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/internal_connection_pool_metrics.rb#86
  def in_use; end

  # Returns the value of attribute pool.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/internal_connection_pool_metrics.rb#5
  def pool; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/internal_connection_pool_metrics.rb#79
  def released(in_use_event); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/internal_connection_pool_metrics.rb#96
  def timed_out_to_acquire; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/internal_connection_pool_metrics.rb#99
  def to_s; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/internal_connection_pool_metrics.rb#96
  def total_acquisition_time; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/internal_connection_pool_metrics.rb#96
  def total_in_use_count; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/internal_connection_pool_metrics.rb#96
  def total_in_use_time; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/internal_metrics.rb#4
class Neo4j::Driver::Internal::Metrics::InternalMetrics
  # @return [InternalMetrics] a new instance of InternalMetrics
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/internal_metrics.rb#5
  def initialize(logger); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/internal_metrics.rb#42
  def after_acquired_or_created(pool_id, acquire_event); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/internal_metrics.rb#38
  def after_acquiring_or_creating(pool_id); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/internal_metrics.rb#30
  def after_closed(pool_id); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/internal_metrics.rb#46
  def after_connection_created(pool_id, in_use_event); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/internal_metrics.rb#50
  def after_connection_released(pool_id, in_use_event); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/internal_metrics.rb#22
  def after_created(pool_id, creating_event); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/internal_metrics.rb#26
  def after_failed_to_create(pool_id); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/internal_metrics.rb#54
  def after_timed_out_to_acquire_or_create(pool_id); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/internal_metrics.rb#34
  def before_acquiring_or_creating(pool_id, acquire_event); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/internal_metrics.rb#18
  def before_creating(pool_id, creating_event); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/internal_metrics.rb#62
  def connection_pool_metrics; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/internal_metrics.rb#58
  def create_listener_event; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/internal_metrics.rb#10
  def put_pool_metrics(pool_id, server_address, pool); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/internal_metrics.rb#14
  def remove_pool_metrics(id); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/internal_metrics.rb#66
  def to_s; end

  private

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/internal_metrics.rb#72
  def pool_metrics(pool_id); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/internal_metrics_provider.rb#4
class Neo4j::Driver::Internal::Metrics::InternalMetricsProvider
  # @return [InternalMetricsProvider] a new instance of InternalMetricsProvider
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/internal_metrics_provider.rb#8
  def initialize(logger); end

  # Returns the value of attribute metrics.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/internal_metrics_provider.rb#5
  def metrics; end

  # @return [Boolean]
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/internal_metrics_provider.rb#12
  def metrics_enabled?; end

  # Returns the value of attribute metrics.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/internal_metrics_provider.rb#5
  def metrics_listener; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/listener_event.rb#4
module Neo4j::Driver::Internal::Metrics::ListenerEvent; end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/listener_event.rb#5
Neo4j::Driver::Internal::Metrics::ListenerEvent::DEV_NULL_LISTENER_EVENT = T.let(T.unsafe(nil), T.untyped)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/metrics_provider.rb#4
module Neo4j::Driver::Internal::Metrics::MetricsProvider; end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/metrics_provider.rb#5
Neo4j::Driver::Internal::Metrics::MetricsProvider::METRICS_DISABLED_PROVIDER = T.let(T.unsafe(nil), T.untyped)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/time_recorder_listener_event.rb#4
class Neo4j::Driver::Internal::Metrics::TimeRecorderListenerEvent
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/time_recorder_listener_event.rb#9
  def elapsed; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/metrics/time_recorder_listener_event.rb#5
  def start; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver.rb#0
module Neo4j::Driver::Internal::Packstream; end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/byte_array_incompatible_packer.rb#4
class Neo4j::Driver::Internal::Packstream::ByteArrayIncompatiblePacker
  include ::Neo4j::Driver::Internal::Packstream::PackStream::Common
  include ::Neo4j::Driver::Internal::Packstream::PackStream::Packer

  # @raise [PackStream::UnPackable]
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/byte_array_incompatible_packer.rb#6
  def pack_bytes_header(_size); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_input.rb#4
module Neo4j::Driver::Internal::Packstream::PackInput
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_input.rb#9
  def read_byte; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_input.rb#5
  def read_char; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_input.rb#41
  def read_double; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_input.rb#25
  def read_int; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_input.rb#33
  def read_long; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_input.rb#17
  def read_short; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_input.rb#13
  def read_ubyte; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_input.rb#29
  def read_uint; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_input.rb#37
  def read_ulong; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_input.rb#21
  def read_ushort; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_output.rb#4
module Neo4j::Driver::Internal::Packstream::PackOutput
  # Produce a single byte
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_output.rb#6
  def write_byte(value); end

  # Produce an 8-byte IEEE 754 "double format" floating-point number
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_output.rb#26
  def write_double(value); end

  # Produce a 4-byte signed integer
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_output.rb#16
  def write_int(value); end

  # Produce an 8-byte signed integer
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_output.rb#21
  def write_long(value); end

  # Produce a 4-byte signed integer
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_output.rb#11
  def write_short(value); end

  private

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_output.rb#32
  def write_value(value, directive); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#4
module Neo4j::Driver::Internal::Packstream::PackStream; end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#5
module Neo4j::Driver::Internal::Packstream::PackStream::Common; end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#23
Neo4j::Driver::Internal::Packstream::PackStream::Common::BYTES_16 = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#24
Neo4j::Driver::Internal::Packstream::PackStream::Common::BYTES_32 = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#22
Neo4j::Driver::Internal::Packstream::PackStream::Common::BYTES_8 = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#12
Neo4j::Driver::Internal::Packstream::PackStream::Common::FALSE = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#11
Neo4j::Driver::Internal::Packstream::PackStream::Common::FLOAT_64 = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#19
Neo4j::Driver::Internal::Packstream::PackStream::Common::INT_16 = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#20
Neo4j::Driver::Internal::Packstream::PackStream::Common::INT_32 = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#21
Neo4j::Driver::Internal::Packstream::PackStream::Common::INT_64 = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#18
Neo4j::Driver::Internal::Packstream::PackStream::Common::INT_8 = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#31
Neo4j::Driver::Internal::Packstream::PackStream::Common::LIST_16 = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#32
Neo4j::Driver::Internal::Packstream::PackStream::Common::LIST_32 = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#30
Neo4j::Driver::Internal::Packstream::PackStream::Common::LIST_8 = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#35
Neo4j::Driver::Internal::Packstream::PackStream::Common::MAP_16 = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#36
Neo4j::Driver::Internal::Packstream::PackStream::Common::MAP_32 = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#34
Neo4j::Driver::Internal::Packstream::PackStream::Common::MAP_8 = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#10
Neo4j::Driver::Internal::Packstream::PackStream::Common::NULL = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#14
Neo4j::Driver::Internal::Packstream::PackStream::Common::RESERVED_C4 = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#15
Neo4j::Driver::Internal::Packstream::PackStream::Common::RESERVED_C5 = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#16
Neo4j::Driver::Internal::Packstream::PackStream::Common::RESERVED_C6 = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#17
Neo4j::Driver::Internal::Packstream::PackStream::Common::RESERVED_C7 = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#25
Neo4j::Driver::Internal::Packstream::PackStream::Common::RESERVED_CF = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#29
Neo4j::Driver::Internal::Packstream::PackStream::Common::RESERVED_D3 = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#33
Neo4j::Driver::Internal::Packstream::PackStream::Common::RESERVED_D7 = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#37
Neo4j::Driver::Internal::Packstream::PackStream::Common::RESERVED_DB = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#40
Neo4j::Driver::Internal::Packstream::PackStream::Common::RESERVED_DE = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#41
Neo4j::Driver::Internal::Packstream::PackStream::Common::RESERVED_DF = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#42
Neo4j::Driver::Internal::Packstream::PackStream::Common::RESERVED_E0 = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#43
Neo4j::Driver::Internal::Packstream::PackStream::Common::RESERVED_E1 = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#44
Neo4j::Driver::Internal::Packstream::PackStream::Common::RESERVED_E2 = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#45
Neo4j::Driver::Internal::Packstream::PackStream::Common::RESERVED_E3 = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#46
Neo4j::Driver::Internal::Packstream::PackStream::Common::RESERVED_E4 = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#47
Neo4j::Driver::Internal::Packstream::PackStream::Common::RESERVED_E5 = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#48
Neo4j::Driver::Internal::Packstream::PackStream::Common::RESERVED_E6 = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#49
Neo4j::Driver::Internal::Packstream::PackStream::Common::RESERVED_E7 = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#50
Neo4j::Driver::Internal::Packstream::PackStream::Common::RESERVED_E8 = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#51
Neo4j::Driver::Internal::Packstream::PackStream::Common::RESERVED_E9 = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#52
Neo4j::Driver::Internal::Packstream::PackStream::Common::RESERVED_EA = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#53
Neo4j::Driver::Internal::Packstream::PackStream::Common::RESERVED_EB = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#54
Neo4j::Driver::Internal::Packstream::PackStream::Common::RESERVED_EC = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#55
Neo4j::Driver::Internal::Packstream::PackStream::Common::RESERVED_ED = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#56
Neo4j::Driver::Internal::Packstream::PackStream::Common::RESERVED_EE = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#57
Neo4j::Driver::Internal::Packstream::PackStream::Common::RESERVED_EF = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#27
Neo4j::Driver::Internal::Packstream::PackStream::Common::STRING_16 = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#28
Neo4j::Driver::Internal::Packstream::PackStream::Common::STRING_32 = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#26
Neo4j::Driver::Internal::Packstream::PackStream::Common::STRING_8 = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#39
Neo4j::Driver::Internal::Packstream::PackStream::Common::STRUCT_16 = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#38
Neo4j::Driver::Internal::Packstream::PackStream::Common::STRUCT_8 = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#7
Neo4j::Driver::Internal::Packstream::PackStream::Common::TINY_LIST = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#8
Neo4j::Driver::Internal::Packstream::PackStream::Common::TINY_MAP = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#6
Neo4j::Driver::Internal::Packstream::PackStream::Common::TINY_STRING = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#9
Neo4j::Driver::Internal::Packstream::PackStream::Common::TINY_STRUCT = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#13
Neo4j::Driver::Internal::Packstream::PackStream::Common::TRUE = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#312
class Neo4j::Driver::Internal::Packstream::PackStream::EndOfStream < ::Neo4j::Driver::Internal::Packstream::PackStream::PackStreamException; end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#68
Neo4j::Driver::Internal::Packstream::PackStream::MINUS_2_TO_THE_15 = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#69
Neo4j::Driver::Internal::Packstream::PackStream::MINUS_2_TO_THE_31 = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#66
Neo4j::Driver::Internal::Packstream::PackStream::MINUS_2_TO_THE_4 = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#70
Neo4j::Driver::Internal::Packstream::PackStream::MINUS_2_TO_THE_63 = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#67
Neo4j::Driver::Internal::Packstream::PackStream::MINUS_2_TO_THE_7 = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#315
class Neo4j::Driver::Internal::Packstream::PackStream::Overflow < ::Neo4j::Driver::Internal::Packstream::PackStream::PackStreamException; end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#63
Neo4j::Driver::Internal::Packstream::PackStream::PLUS_2_TO_THE_15 = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#62
Neo4j::Driver::Internal::Packstream::PackStream::PLUS_2_TO_THE_16 = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#61
Neo4j::Driver::Internal::Packstream::PackStream::PLUS_2_TO_THE_31 = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#60
Neo4j::Driver::Internal::Packstream::PackStream::PLUS_2_TO_THE_63 = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#65
Neo4j::Driver::Internal::Packstream::PackStream::PLUS_2_TO_THE_7 = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#64
Neo4j::Driver::Internal::Packstream::PackStream::PLUS_2_TO_THE_8 = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#309
class Neo4j::Driver::Internal::Packstream::PackStream::PackStreamException < ::IOError; end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#72
module Neo4j::Driver::Internal::Packstream::PackStream::Packer
  include ::Neo4j::Driver::Internal::Packstream::PackStream::Common

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#82
  def pack(value); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#158
  def pack_bytes_header(size); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#144
  def pack_float(value); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#128
  def pack_integer(value); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#180
  def pack_list_header(size); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#192
  def pack_map_header(size); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#78
  def pack_null; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#168
  def pack_string_header(size); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#204
  def pack_struct_header(size, signature); end

  private

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#148
  def pack_bytes(value); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#74
  def pack_raw(data); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#153
  def pack_string(value); end

  # @raise [UnPackable]
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#124
  def unpackable(value); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#321
class Neo4j::Driver::Internal::Packstream::PackStream::UnPackable < ::Neo4j::Driver::Internal::Packstream::PackStream::PackStreamException; end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#318
class Neo4j::Driver::Internal::Packstream::PackStream::Unexpected < ::Neo4j::Driver::Internal::Packstream::PackStream::PackStreamException; end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#217
module Neo4j::Driver::Internal::Packstream::PackStream::Unpacker
  include ::Neo4j::Driver::Internal::Packstream::PackStream::Common

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#300
  def unpack_bytes(size); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#296
  def unpack_double; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#241
  def unpack_list_header; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#279
  def unpack_long(marker_byte); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#260
  def unpack_map_header; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#304
  def unpack_string(size); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#220
  def unpack_struct_header; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_stream.rb#237
  def unpack_struct_signature; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_type.rb#4
class Neo4j::Driver::Internal::Packstream::PackType; end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_type.rb#6
Neo4j::Driver::Internal::Packstream::PackType::BOOLEAN = T.let(T.unsafe(nil), Symbol)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_type.rb#9
Neo4j::Driver::Internal::Packstream::PackType::BYTES = T.let(T.unsafe(nil), Symbol)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_type.rb#8
Neo4j::Driver::Internal::Packstream::PackType::FLOAT = T.let(T.unsafe(nil), Symbol)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_type.rb#7
Neo4j::Driver::Internal::Packstream::PackType::INTEGER = T.let(T.unsafe(nil), Symbol)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_type.rb#11
Neo4j::Driver::Internal::Packstream::PackType::LIST = T.let(T.unsafe(nil), Symbol)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_type.rb#12
Neo4j::Driver::Internal::Packstream::PackType::MAP = T.let(T.unsafe(nil), Symbol)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_type.rb#5
Neo4j::Driver::Internal::Packstream::PackType::NULL = T.let(T.unsafe(nil), Symbol)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_type.rb#10
Neo4j::Driver::Internal::Packstream::PackType::STRING = T.let(T.unsafe(nil), Symbol)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/packstream/pack_type.rb#13
Neo4j::Driver::Internal::Packstream::PackType::STRUCT = T.let(T.unsafe(nil), Symbol)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/read_only_bookmark_holder.rb#3
class Neo4j::Driver::Internal::ReadOnlyBookmarkHolder
  # @return [ReadOnlyBookmarkHolder] a new instance of ReadOnlyBookmarkHolder
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/read_only_bookmark_holder.rb#6
  def initialize(bookmark = T.unsafe(nil)); end

  # Returns the value of attribute bookmark.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/read_only_bookmark_holder.rb#4
  def bookmark; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/read_only_bookmark_holder.rb#10
  def bookmark=(_value); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/resolved_bolt_server_address.rb#3
class Neo4j::Driver::Internal::ResolvedBoltServerAddress < ::Neo4j::Driver::Internal::BoltServerAddress
  # @return [ResolvedBoltServerAddress] a new instance of ResolvedBoltServerAddress
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/resolved_bolt_server_address.rb#6
  def initialize(host, port, *resolved_addresses_arr); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/resolved_bolt_server_address.rb#25
  def attributes; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/resolved_bolt_server_address.rb#29
  def create_string_representation; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/resolved_bolt_server_address.rb#21
  def to_s; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/resolved_bolt_server_address.rb#16
  def unicast_stream; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/resolved_bolt_server_address.rb#4
Neo4j::Driver::Internal::ResolvedBoltServerAddress::MAX_HOST_ADDRESSES_IN_STRING_VALUE = T.let(T.unsafe(nil), Integer)

# source://neo4j-ruby-driver//ruby/neo4j/driver/config.rb#0
module Neo4j::Driver::Internal::Retry; end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/retry/exponential_backoff_retry_logic.rb#6
class Neo4j::Driver::Internal::Retry::ExponentialBackoffRetryLogic
  # @return [ExponentialBackoffRetryLogic] a new instance of ExponentialBackoffRetryLogic
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/retry/exponential_backoff_retry_logic.rb#12
  def initialize(max_retry_time, event_executor_group, logger = T.unsafe(nil)); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/retry/exponential_backoff_retry_logic.rb#18
  def retry; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/retry/exponential_backoff_retry_logic.rb#43
  def retry_async(&work); end

  protected

  # @return [Boolean]
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/retry/exponential_backoff_retry_logic.rb#51
  def can_retry_on?(error); end

  private

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/retry/exponential_backoff_retry_logic.rb#145
  def add_suppressed(error, suppressed_errors); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/retry/exponential_backoff_retry_logic.rb#123
  def compute_delay_with_jitter(delay); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/retry/exponential_backoff_retry_logic.rb#85
  def execute_work(result_future, start_time, retry_delay, errors, &work); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/retry/exponential_backoff_retry_logic.rb#64
  def execute_work_in_event_loop(result_future, &work); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/retry/exponential_backoff_retry_logic.rb#59
  def extract_possible_termination_cause(error); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/retry/exponential_backoff_retry_logic.rb#141
  def record_error(error, errors); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/retry/exponential_backoff_retry_logic.rb#105
  def retry_on_error(result_future, start_time, retry_delay, throwable, errors, &work); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/retry/exponential_backoff_retry_logic.rb#73
  def retry_work_in_event_loop(result_future, error, start_time, delay, errors, &work); end

  # @return [Boolean]
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/retry/exponential_backoff_retry_logic.rb#131
  def transient_error?(error); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/retry/exponential_backoff_retry_logic.rb#7
Neo4j::Driver::Internal::Retry::ExponentialBackoffRetryLogic::DEFAULT_MAX_RETRY_TIME = T.let(T.unsafe(nil), ActiveSupport::Duration)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/retry/exponential_backoff_retry_logic.rb#8
Neo4j::Driver::Internal::Retry::ExponentialBackoffRetryLogic::INITIAL_RETRY_DELAY = T.let(T.unsafe(nil), ActiveSupport::Duration)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/retry/exponential_backoff_retry_logic.rb#10
Neo4j::Driver::Internal::Retry::ExponentialBackoffRetryLogic::RETRY_DELAY_JITTER_FACTOR = T.let(T.unsafe(nil), Float)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/retry/exponential_backoff_retry_logic.rb#9
Neo4j::Driver::Internal::Retry::ExponentialBackoffRetryLogic::RETRY_DELAY_MULTIPLIER = T.let(T.unsafe(nil), Float)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/revocation_strategy.rb#4
module Neo4j::Driver::Internal::RevocationStrategy
  class << self
    # @return [Boolean]
    #
    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/revocation_strategy.rb#15
    def requires_revocation_checking?(revocation_strategy); end
  end
end

# Don't do any OCSP revocation checks, regardless whether there are stapled revocation statuses or not.
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/revocation_strategy.rb#6
Neo4j::Driver::Internal::RevocationStrategy::NO_CHECKS = T.let(T.unsafe(nil), Symbol)

# Require stapled revocation status and verify OCSP revocation checks,
# fail if no revocation status is stapled to the certificate.
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/revocation_strategy.rb#13
Neo4j::Driver::Internal::RevocationStrategy::STRICT = T.let(T.unsafe(nil), Symbol)

# Verify OCSP revocation checks when the revocation status is stapled to the certificate, continue if not.
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/revocation_strategy.rb#9
Neo4j::Driver::Internal::RevocationStrategy::VERIFY_IF_PRESENT = T.let(T.unsafe(nil), Symbol)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/scheme.rb#1
module Neo4j::Driver::Internal::Scheme
  # @return [Boolean]
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/scheme.rb#16
  def high_trust_scheme?(scheme); end

  # @return [Boolean]
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/scheme.rb#20
  def low_trust_scheme?(scheme); end

  # @return [Boolean]
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/scheme.rb#29
  def routing_scheme?(scheme); end

  # @return [Boolean]
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/scheme.rb#24
  def security_scheme?(scheme); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/scheme.rb#9
  def validate_scheme!(scheme); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/scheme.rb#3
Neo4j::Driver::Internal::Scheme::BOLT_HIGH_TRUST_URI_SCHEME = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/scheme.rb#4
Neo4j::Driver::Internal::Scheme::BOLT_LOW_TRUST_URI_SCHEME = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/scheme.rb#2
Neo4j::Driver::Internal::Scheme::BOLT_URI_SCHEME = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/scheme.rb#6
Neo4j::Driver::Internal::Scheme::NEO4J_HIGH_TRUST_URI_SCHEME = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/scheme.rb#7
Neo4j::Driver::Internal::Scheme::NEO4J_LOW_TRUST_URI_SCHEME = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/scheme.rb#5
Neo4j::Driver::Internal::Scheme::NEO4J_URI_SCHEME = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//ruby/neo4j/driver.rb#0
module Neo4j::Driver::Internal::Security; end

# A simple common token for authentication schemes that easily convert to
# an auth token map
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/security/internal_auth_token.rb#6
class Neo4j::Driver::Internal::Security::InternalAuthToken < ::Hash; end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/security/internal_auth_token.rb#9
Neo4j::Driver::Internal::Security::InternalAuthToken::CREDENTIALS_KEY = T.let(T.unsafe(nil), Symbol)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/security/internal_auth_token.rb#11
Neo4j::Driver::Internal::Security::InternalAuthToken::PARAMETERS_KEY = T.let(T.unsafe(nil), Symbol)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/security/internal_auth_token.rb#8
Neo4j::Driver::Internal::Security::InternalAuthToken::PRINCIPAL_KEY = T.let(T.unsafe(nil), Symbol)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/security/internal_auth_token.rb#10
Neo4j::Driver::Internal::Security::InternalAuthToken::REALM_KEY = T.let(T.unsafe(nil), Symbol)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/security/internal_auth_token.rb#7
Neo4j::Driver::Internal::Security::InternalAuthToken::SCHEME_KEY = T.let(T.unsafe(nil), Symbol)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/security/security_plan_impl.rb#4
class Neo4j::Driver::Internal::Security::SecurityPlanImpl < ::Struct
  class << self
    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/security/security_plan_impl.rb#6
    def for_all_certificates(requires_hostname_verification, revocation_strategy); end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/security/security_plan_impl.rb#10
    def for_custom_ca_signed_certificates(cert_files, requires_hostname_verification, revocation_strategy); end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/security/security_plan_impl.rb#15
    def for_system_ca_signed_certificates(requires_hostname_verification, revocation_strategy); end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/security/security_plan_impl.rb#20
    def insecure; end

    private

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/security/security_plan_impl.rb#26
    def all_context(requires_hostname_verification); end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/security/security_plan_impl.rb#30
    def ca_signed_context(requires_hostname_verification); end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/security/security_plan_impl.rb#34
    def custom_ca_signed_context(cert_files, requires_hostname_verification); end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/security/security_plan_impl.rb#42
    def ssl_context(**params); end
  end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/security_setting.rb#5
class Neo4j::Driver::Internal::SecuritySetting
  include ::Neo4j::Driver::Internal::Scheme

  # @return [SecuritySetting] a new instance of SecuritySetting
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/security_setting.rb#10
  def initialize(encrypted, trust_strategy, customized); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/security_setting.rb#16
  def create_security_plan(uri_scheme); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/security_setting.rb#28
  def create_security_plan_from_scheme(uri_scheme); end

  # Returns the value of attribute customized.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/security_setting.rb#8
  def customized; end

  # Returns the value of attribute encrypted.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/security_setting.rb#8
  def encrypted; end

  # Returns the value of attribute trust_strategy.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/security_setting.rb#8
  def trust_strategy; end

  private

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/security_setting.rb#38
  def assert_security_settings_not_user_configured(uri_scheme); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/security_setting.rb#45
  def create_security_plan_impl(encrypted, trust_strategy); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/session_factory_impl.rb#3
class Neo4j::Driver::Internal::SessionFactoryImpl
  # @return [SessionFactoryImpl] a new instance of SessionFactoryImpl
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/session_factory_impl.rb#7
  def initialize(connection_provider, retry_logic, config); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/session_factory_impl.rb#5
  def close(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute connection_provider.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/session_factory_impl.rb#4
  def connection_provider; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/session_factory_impl.rb#15
  def new_instance(fetch_size: T.unsafe(nil), default_access_mode: T.unsafe(nil), **config); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/session_factory_impl.rb#5
  def supports_multi_db?(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/session_factory_impl.rb#5
  def verify_connectivity(*_arg0, **_arg1, &_arg2); end

  private

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/session_factory_impl.rb#26
  def create_session(database_name, mode, bookmark_holder, fetch_size, impersonated_user); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/session_factory_impl.rb#22
  def parse_database_name(config); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver.rb#0
module Neo4j::Driver::Internal::Spi; end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/spi/connection.rb#4
module Neo4j::Driver::Internal::Spi::Connection
  # @raise [java.lang.UnsupportedOperationException]
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/spi/connection.rb#9
  def database_name; end

  # @raise [java.lang.UnsupportedOperationException]
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/spi/connection.rb#13
  def impersonated_user; end

  # @raise [java.lang.UnsupportedOperationException]
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/spi/connection.rb#5
  def mode; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/spi/connection_pool.rb#4
module Neo4j::Driver::Internal::Spi::ConnectionPool; end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/spi/connection_pool.rb#5
Neo4j::Driver::Internal::Spi::ConnectionPool::CONNECTION_POOL_CLOSED_ERROR_MESSAGE = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/spi/response_handler.rb#4
module Neo4j::Driver::Internal::Spi::ResponseHandler
  # Tells whether this response handler is able to manage auto-read of the underlying connection using {@link Connection#enableAutoRead()} and
  # {@link Connection#disableAutoRead()}.
  # <p>
  # Implementations can use auto-read management to apply network-level backpressure when receiving a stream of records.
  # There should only be a single such handler active for a connection at one point in time. Otherwise, handlers can interfere and turn on/off auto-read
  # racing with each other. {@link InboundMessageDispatcher} is responsible for tracking these handlers and disabling auto-read management to maintain just
  # a single auto-read managing handler per connection.
  #
  # @return [Boolean]
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/spi/response_handler.rb#12
  def can_manage_auto_read?; end

  # If this response handler is able to manage auto-read of the underlying connection, then this method signals it to
  # stop changing auto-read setting for the connection.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/spi/response_handler.rb#18
  def disable_auto_read_management; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver.rb#0
module Neo4j::Driver::Internal::Summary; end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/summary/internal_database_info.rb#4
class Neo4j::Driver::Internal::Summary::InternalDatabaseInfo < ::Struct; end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/summary/internal_database_info.rb#5
Neo4j::Driver::Internal::Summary::InternalDatabaseInfo::DEFAULT_DATABASE_INFO = T.let(T.unsafe(nil), Neo4j::Driver::Internal::Summary::InternalDatabaseInfo)

# Creating a position from and offset, line number and a column number.
#
# @param offset the offset from the start of the string, starting from 0.
# @param line the line number, starting from 1.
# @param column the column number, starting from 1.
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/summary/internal_input_position.rb#9
class Neo4j::Driver::Internal::Summary::InternalInputPosition < ::Struct; end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/summary/internal_notification.rb#4
class Neo4j::Driver::Internal::Summary::InternalNotification < ::Struct; end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/summary/internal_notification.rb#6
Neo4j::Driver::Internal::Summary::InternalNotification::VALUE_TO_NOTIFICATION = T.let(T.unsafe(nil), Proc)

# Only call #initialize when sub-classing, for constructing plans, use .plan instead
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/summary/internal_plan.rb#5
class Neo4j::Driver::Internal::Summary::InternalPlan < ::Struct
  class << self
    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/summary/internal_plan.rb#37
    def plan(operator_type, arguments, identifiers, children); end
  end
end

# Since a plan with or without profiling looks almost the same, we just keep two impls. of this
# around to contain the small difference, and share the rest of the code for building plan trees.
#
# @param [T]
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/summary/internal_plan.rb#10
class Neo4j::Driver::Internal::Summary::InternalPlan::Converter
  # @return [Converter] a new instance of Converter
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/summary/internal_plan.rb#11
  def initialize(&plan_creator); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/summary/internal_plan.rb#15
  def apply(plan); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/summary/internal_plan.rb#31
Neo4j::Driver::Internal::Summary::InternalPlan::EXPLAIN_PLAN = T.let(T.unsafe(nil), Proc)

# Builds a regular plan without profiling information - eg. a plan that came as a result of an `EXPLAIN` query
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/summary/internal_plan.rb#35
Neo4j::Driver::Internal::Summary::InternalPlan::EXPLAIN_PLAN_FROM_VALUE = T.let(T.unsafe(nil), Method)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/summary/internal_profiled_plan.rb#4
class Neo4j::Driver::Internal::Summary::InternalProfiledPlan < ::Neo4j::Driver::Internal::Summary::InternalPlan
  # @return [InternalProfiledPlan] a new instance of InternalProfiledPlan
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/summary/internal_profiled_plan.rb#18
  def initialize(operator_type, arguments, identifiers, children, db_hits, records, page_cache_hits, page_cache_misses, page_cache_hit_ratio, time); end

  # Returns the value of attribute db_hits.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/summary/internal_profiled_plan.rb#5
  def db_hits; end

  # Returns the value of attribute page_cache_hit_ratio.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/summary/internal_profiled_plan.rb#5
  def page_cache_hit_ratio; end

  # Returns the value of attribute page_cache_hits.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/summary/internal_profiled_plan.rb#5
  def page_cache_hits; end

  # Returns the value of attribute page_cache_misses.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/summary/internal_profiled_plan.rb#5
  def page_cache_misses; end

  # @return [Boolean]
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/summary/internal_profiled_plan.rb#28
  def page_cache_stats?; end

  # Returns the value of attribute records.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/summary/internal_profiled_plan.rb#5
  def records; end

  # Returns the value of attribute time.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/summary/internal_profiled_plan.rb#5
  def time; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/summary/internal_profiled_plan.rb#7
Neo4j::Driver::Internal::Summary::InternalProfiledPlan::PROFILED_PLAN = T.let(T.unsafe(nil), Proc)

# Builds a regular plan without profiling information - eg. a plan that came as a result of an `EXPLAIN` query
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/summary/internal_profiled_plan.rb#16
Neo4j::Driver::Internal::Summary::InternalProfiledPlan::PROFILED_PLAN_FROM_VALUE = T.let(T.unsafe(nil), Method)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/summary/internal_result_summary.rb#5
class Neo4j::Driver::Internal::Summary::InternalResultSummary < ::Struct
  # @return [InternalResultSummary] a new instance of InternalResultSummary
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/summary/internal_result_summary.rb#9
  def initialize(*args); end

  # Returns the value of attribute counters
  #
  # @return [Object] the current value of counters
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/summary/internal_result_summary.rb#14
  def counters; end

  # Returns the value of attribute plan
  #
  # @return [Object] the current value of plan
  def has_plan?; end

  # Returns the value of attribute profile
  #
  # @return [Object] the current value of profile
  def has_profile?; end

  # Returns the value of attribute notifications
  #
  # @return [Object] the current value of notifications
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/summary/internal_result_summary.rb#18
  def notifications; end

  private

  # Profiled plan is a superset of plan. This method returns profiled plan if plan is {@code null}.
  #
  # @param plan the given plan, possibly {@code null}.
  # @param profiled_plan the given profiled plan, possibly {@code null}.
  # @return available plan.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/summary/internal_result_summary.rb#29
  def resolve_plan(plan, profiled_plan); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/summary/internal_server_info.rb#4
class Neo4j::Driver::Internal::Summary::InternalServerInfo < ::Struct; end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/summary/internal_summary_counters.rb#7
class Neo4j::Driver::Internal::Summary::InternalSummaryCounters < ::Struct
  # @return [Boolean]
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/summary/internal_summary_counters.rb#14
  def contains_system_updates?; end

  # @return [Boolean]
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/summary/internal_summary_counters.rb#10
  def contains_updates?; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/summary/internal_summary_counters.rb#8
Neo4j::Driver::Internal::Summary::InternalSummaryCounters::EMPTY_STATS = T.let(T.unsafe(nil), Neo4j::Driver::Internal::Summary::InternalSummaryCounters)

# source://neo4j-ruby-driver//ruby/neo4j/driver.rb#0
module Neo4j::Driver::Internal::Svm
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/svm/netty_substitutions.rb#39
  def Target_io_netty_handler_ssl_JdkAlpnApplicationProtocolNegotiator_AlpnWrapperJava8; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/svm/netty_substitutions.rb#192
class Neo4j::Driver::Internal::Svm::NettySubstitutions; end

# This one only prints exceptions otherwise we get a useless bogus
# exception message: https://github.com/eclipse-vertx/vert.x/issues/1657
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/svm/netty_substitutions.rb#146
class Neo4j::Driver::Internal::Svm::Target_io_netty_bootstrap_AbstractBootstrap
  # @return [Target_io_netty_bootstrap_AbstractBootstrap] a new instance of Target_io_netty_bootstrap_AbstractBootstrap
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/svm/netty_substitutions.rb#147
  def initialize(channel); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/svm/netty_substitutions.rb#151
  def config; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/svm/netty_substitutions.rb#155
  def init_and_register; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/svm/netty_substitutions.rb#33
class Neo4j::Driver::Internal::Svm::Target_io_netty_handler_ssl_JdkAlpnApplicationProtocolNegotiator_AlpnWrapper
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/svm/netty_substitutions.rb#34
  def wrap_ssl_engine(engine, alloc, application_negotiator, server); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/svm/netty_substitutions.rb#63
class Neo4j::Driver::Internal::Svm::Target_io_netty_handler_ssl_JdkAlpnSslEngine
  # @return [Target_io_netty_handler_ssl_JdkAlpnSslEngine] a new instance of Target_io_netty_handler_ssl_JdkAlpnSslEngine
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/svm/netty_substitutions.rb#64
  def initialize(engine, application_negotiator, server); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/svm/netty_substitutions.rb#95
class Neo4j::Driver::Internal::Svm::Target_io_netty_handler_ssl_JdkDefaultApplicationProtocolNegotiator; end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/svm/netty_substitutions.rb#96
Neo4j::Driver::Internal::Svm::Target_io_netty_handler_ssl_JdkDefaultApplicationProtocolNegotiator::INSTANCE = T.let(T.unsafe(nil), Symbol)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/svm/netty_substitutions.rb#19
class Neo4j::Driver::Internal::Svm::Target_io_netty_handler_ssl_JdkSslClientContext
  # @return [Target_io_netty_handler_ssl_JdkSslClientContext] a new instance of Target_io_netty_handler_ssl_JdkSslClientContext
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/svm/netty_substitutions.rb#20
  def initialize(ssl_context_provider, trust_cert_collection, trust_manager_factory, key_cert_chain, key, key_password, key_manager_factory, ciphers, cipher_filter, apn, protocols, session_cache_size, session_timeout, key_store_type); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/svm/netty_substitutions.rb#99
class Neo4j::Driver::Internal::Svm::Target_io_netty_handler_ssl_JdkSslContext
  class << self
    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/svm/netty_substitutions.rb#100
    def to_negotiator(config, server); end
  end
end

# SSL
# This whole section is mostly about removing static analysis references to openssl/tcnative
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/svm/netty_substitutions.rb#12
class Neo4j::Driver::Internal::Svm::Target_io_netty_handler_ssl_JdkSslServerContext
  # @return [Target_io_netty_handler_ssl_JdkSslServerContext] a new instance of Target_io_netty_handler_ssl_JdkSslServerContext
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/svm/netty_substitutions.rb#13
  def initialize(provider, trust_cert_collection, trust_manager_factory, key_cert_chain, key, key_password, key_manager_factory, ciphers, cipher_filter, apn, session_cache_size, session_timeout, client_auth, protocols, start_tls, key_store); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/svm/netty_substitutions.rb#49
class Neo4j::Driver::Internal::Svm::Target_io_netty_handler_ssl_JettyAlpnSslEngine
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/svm/netty_substitutions.rb#54
  def new_client_engine(engine, application_negotiator); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/svm/netty_substitutions.rb#58
  def new_server_engine(engine, application_negotiator); end

  class << self
    # @return [Boolean]
    #
    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/svm/netty_substitutions.rb#50
    def available?; end
  end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/svm/netty_substitutions.rb#68
class Neo4j::Driver::Internal::Svm::Target_io_netty_handler_ssl_SslContext
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/svm/netty_substitutions.rb#82
  def new_client_context_internal(provider, ssl_context_provider, trust_cert, trust_manager_factory, key_cert_chain, key, key_password, key_manager_factory, ciphers, cipher_filter, apn, protocols, session_cache_size, session_timeout, enable_ocsp, key_store_type, options); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/svm/netty_substitutions.rb#26
class Neo4j::Driver::Internal::Svm::Target_io_netty_handler_ssl_SslHandler
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/svm/netty_substitutions.rb#28
  def for_engine; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/svm/netty_substitutions.rb#27
Neo4j::Driver::Internal::Svm::Target_io_netty_handler_ssl_SslHandler::JDK = T.let(T.unsafe(nil), T.untyped)

# This substitution avoid having loggers added to the build
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/svm/netty_substitutions.rb#5
class Neo4j::Driver::Internal::Svm::Target_io_netty_util_internal_logging_InternalLoggerFactory
  class << self
    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/svm/netty_substitutions.rb#6
    def new_default_factory(name); end
  end
end

# This substitution avoid having jcraft zlib added to the build
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/svm/z_lib_substitutions.rb#5
class Neo4j::Driver::Internal::Svm::Target_org_neo4j_driver_internal_shaded_io_netty_handler_codec_compression_ZlibCodecFactory
  class << self
    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/svm/z_lib_substitutions.rb#7
    def new_zlib_encoder(wrapper, compression_level); end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/svm/z_lib_substitutions.rb#11
    def zlib_decoder(wrapper); end
  end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/svm/z_lib_substitutions.rb#17
class Neo4j::Driver::Internal::Svm::ZLibSubstitutions; end

# source://neo4j-ruby-driver//ruby/neo4j/driver.rb#0
module Neo4j::Driver::Internal::Util; end

# A tool used to save, load certs, etc.
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/certificate_tool.rb#6
class Neo4j::Driver::Internal::Util::CertificateTool
  class << self
    # @param certFile
    # @param keyStore
    #
    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/certificate_tool.rb#41
    def load_x509_cert(cert_file, key_store); end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/certificate_tool.rb#15
    def save_x509_cert(cert_str, cert_file); end
  end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/certificate_tool.rb#7
Neo4j::Driver::Internal::Util::CertificateTool::BEGIN_CERT = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/certificate_tool.rb#8
Neo4j::Driver::Internal::Util::CertificateTool::END_CERT = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/clock.rb#4
module Neo4j::Driver::Internal::Util::Clock; end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/clock.rb#5
module Neo4j::Driver::Internal::Util::Clock::System
  class << self
    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/clock.rb#7
    def millis; end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/clock.rb#15
    def sleep(duration); end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/clock.rb#11
    def time; end

    private

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/clock.rb#21
    def gettime(unit); end
  end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/error_util.rb#4
class Neo4j::Driver::Internal::Util::ErrorUtil
  class << self
    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/error_util.rb#61
    def add_suppressed(main_error, error); end

    # @return [Boolean]
    #
    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/error_util.rb#43
    def fatal?(error); end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/error_util.rb#65
    def get_root_cause(error); end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/error_util.rb#16
    def new_connection_terminated_error(reason); end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/error_util.rb#28
    def new_neo4j_error(code, message); end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/error_util.rb#21
    def new_result_consumed_error; end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/error_util.rb#49
    def rethrow_async_exception(exception); end

    private

    # @return [Boolean]
    #
    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/error_util.rb#99
    def client_or_transient_error?(error_code); end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/error_util.rb#90
    def extract_class_from_code(code, parts_counts); end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/error_util.rb#82
    def extract_error_class(code); end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/error_util.rb#86
    def extract_error_sub_class(code); end

    # @return [Boolean]
    #
    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/error_util.rb#95
    def protocol_violation_error?(error_code); end
  end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/error_util.rb#5
Neo4j::Driver::Internal::Util::ErrorUtil::DEFAULT_CONN_TERMINATED_REASON = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/error_util.rb#9
Neo4j::Driver::Internal::Util::ErrorUtil::SEC_EXCEPTION_CODE_MAPPING = T.let(T.unsafe(nil), Hash)

# Utility class for extracting data.
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/extract.rb#5
class Neo4j::Driver::Internal::Util::Extract
  # @return [Extract] a new instance of Extract
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/extract.rb#6
  def initialize; end

  class << self
    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/extract.rb#106
    def assert_parameter(value); end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/extract.rb#70
    def fields(map, map_function); end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/extract.rb#11
    def list(data, map_function); end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/extract.rb#29
    def map(record, map_function); end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/extract.rb#93
    def map_of_values(map); end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/extract.rb#48
    def properties(map, map_function); end
  end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/format.rb#4
class Neo4j::Driver::Internal::Util::Format
  # @return [Format] a new instance of Format
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/format.rb#5
  def initialize; end

  class << self
    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/format.rb#11
    def format_pairs(entries); end

    private

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/format.rb#32
    def key_value_string(entry); end
  end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/futures.rb#6
class Neo4j::Driver::Internal::Util::Futures
  class << self
    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/futures.rb#28
    def blocking_get(stage); end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/futures.rb#63
    def combine_errors(error1, error2); end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/futures.rb#16
    def completed_with_null; end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/futures.rb#20
    def completed_with_null_if_no_error(future, error); end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/futures.rb#24
    def failed_future(error); end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/futures.rb#85
    def future_completing_consumer(future, fulfilled, value, throwable); end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/futures.rb#51
    def get_now(stage); end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/futures.rb#55
    def join_now_or_else_throw(future); end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/futures.rb#68
    def on_error_continue(future, error_recorder); end

    private

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/futures.rb#93
    def no_op_interrupt_handler; end
  end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/futures.rb#11
Neo4j::Driver::Internal::Util::Futures::COMPLETED_WITH_NULL = T.let(T.unsafe(nil), Concurrent::Promises::Future)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/iterables.rb#4
class Neo4j::Driver::Internal::Util::Iterables
  class << self
    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/iterables.rb#22
    def map(alternating_key_value); end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/iterables.rb#8
    def single(it); end
  end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/iterables.rb#5
Neo4j::Driver::Internal::Util::Iterables::EMPTY_QUEUE = T.let(T.unsafe(nil), Thread::Queue)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/lock_util.rb#4
class Neo4j::Driver::Internal::Util::LockUtil
  class << self
    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/lock_util.rb#6
    def execute_with_lock(lock); end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/lock_util.rb#15
    def execute_with_lock_async(lock); end
  end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/metadata_extractor.rb#4
class Neo4j::Driver::Internal::Util::MetadataExtractor
  # @return [MetadataExtractor] a new instance of MetadataExtractor
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/metadata_extractor.rb#5
  def initialize(result_available_after_metadata_key, result_consumed_after_metadata_key); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/metadata_extractor.rb#14
  def extract_query_id(metadata); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/metadata_extractor.rb#10
  def extract_query_keys(metadata); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/metadata_extractor.rb#18
  def extract_result_available_after(metadata); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/metadata_extractor.rb#22
  def extract_summary(query, connection, result_available_after, metadata); end

  class << self
    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/metadata_extractor.rb#38
    def extract_bookmarks(metadata); end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/metadata_extractor.rb#65
    def extract_counters(metadata); end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/metadata_extractor.rb#33
    def extract_database_info(metadata); end

    # @raise [Neo4j::Driver::Exceptions::UntrustedServerException]
    #
    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/metadata_extractor.rb#46
    def extract_neo4j_server_version(metadata); end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/metadata_extractor.rb#94
    def extract_notifications(metadata); end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/metadata_extractor.rb#86
    def extract_plan(metadata); end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/metadata_extractor.rb#90
    def extract_profiled_plan(metadata); end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/metadata_extractor.rb#61
    def extract_query_type(metadata); end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/metadata_extractor.rb#100
    def extract_result_consumed_after(metadata, key); end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/metadata_extractor.rb#53
    def extract_server(metadata); end
  end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/mutex.rb#3
class Neo4j::Driver::Internal::Util::Mutex < ::Thread::Mutex
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/mutex.rb#4
  def synchronize; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/preconditions.rb#4
class Neo4j::Driver::Internal::Util::Preconditions
  class << self
    # @param expression the value to check.
    # @param message the message.
    # @raise [ArgumentError]
    #
    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/preconditions.rb#10
    def check_argument(expression, message); end
  end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/result_holder.rb#4
class Neo4j::Driver::Internal::Util::ResultHolder
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/result_holder.rb#51
  def chain; end

  # &block returns a ResultHolder
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/result_holder.rb#47
  def compose; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/result_holder.rb#62
  def copy_to(result_holder); end

  # Returns the value of attribute error.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/result_holder.rb#5
  def error; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/result_holder.rb#26
  def fail(error); end

  # @raise [@error]
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/result_holder.rb#37
  def result!; end

  # @yield [@result, @error]
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/result_holder.rb#57
  def side; end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/result_holder.rb#15
  def succeed(result = T.unsafe(nil)); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/result_holder.rb#42
  def then; end

  class << self
    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/result_holder.rb#11
    def failed(error); end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/result_holder.rb#7
    def successful(result = T.unsafe(nil)); end
  end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/server_version.rb#4
class Neo4j::Driver::Internal::Util::ServerVersion < ::Struct
  include ::Comparable

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/server_version.rb#18
  def <=>(other); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/server_version.rb#25
  def to_s; end

  class << self
    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/server_version.rb#41
    def from_bolt_protocol_version(protocol_version); end

    # @raise [ArgumentError]
    #
    # source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/server_version.rb#29
    def version(server); end
  end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/server_version.rb#15
Neo4j::Driver::Internal::Util::ServerVersion::NEO4J_IN_DEV_VERSION_STRING = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/server_version.rb#6
Neo4j::Driver::Internal::Util::ServerVersion::NEO4J_PRODUCT = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/server_version.rb#16
Neo4j::Driver::Internal::Util::ServerVersion::PATTERN = T.let(T.unsafe(nil), Regexp)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/server_version.rb#13
Neo4j::Driver::Internal::Util::ServerVersion::V3_4_0 = T.let(T.unsafe(nil), Neo4j::Driver::Internal::Util::ServerVersion)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/server_version.rb#12
Neo4j::Driver::Internal::Util::ServerVersion::V3_5_0 = T.let(T.unsafe(nil), Neo4j::Driver::Internal::Util::ServerVersion)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/server_version.rb#11
Neo4j::Driver::Internal::Util::ServerVersion::V4_0_0 = T.let(T.unsafe(nil), Neo4j::Driver::Internal::Util::ServerVersion)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/server_version.rb#10
Neo4j::Driver::Internal::Util::ServerVersion::V4_1_0 = T.let(T.unsafe(nil), Neo4j::Driver::Internal::Util::ServerVersion)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/server_version.rb#9
Neo4j::Driver::Internal::Util::ServerVersion::V4_2_0 = T.let(T.unsafe(nil), Neo4j::Driver::Internal::Util::ServerVersion)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/server_version.rb#8
Neo4j::Driver::Internal::Util::ServerVersion::V4_3_0 = T.let(T.unsafe(nil), Neo4j::Driver::Internal::Util::ServerVersion)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/server_version.rb#7
Neo4j::Driver::Internal::Util::ServerVersion::V4_4_0 = T.let(T.unsafe(nil), Neo4j::Driver::Internal::Util::ServerVersion)

# source://neo4j-ruby-driver//ruby/neo4j/driver/internal/util/server_version.rb#14
Neo4j::Driver::Internal::Util::ServerVersion::V_IN_DEV = T.let(T.unsafe(nil), Neo4j::Driver::Internal::Util::ServerVersion)

# source://neo4j-ruby-driver//lib/neo4j/driver/internal/validator.rb#6
module Neo4j::Driver::Internal::Validator
  class << self
    # @raise [ArgumentError]
    #
    # source://neo4j-ruby-driver//lib/neo4j/driver/internal/validator.rb#13
    def require_hash!(obj); end

    # source://neo4j-ruby-driver//lib/neo4j/driver/internal/validator.rb#7
    def require_hash_parameters!(parameters); end

    # @raise [ArgumentError]
    #
    # source://neo4j-ruby-driver//lib/neo4j/driver/internal/validator.rb#17
    def require_non_nil!(obj, message = T.unsafe(nil)); end

    # source://neo4j-ruby-driver//lib/neo4j/driver/internal/validator.rb#22
    def require_non_nil_credentials!(username, password); end
  end
end

# source://neo4j-ruby-driver//lib/neo4j-ruby-driver_loader.rb#18
class Neo4j::Driver::Loader
  class << self
    # @yield [loader]
    #
    # source://neo4j-ruby-driver//lib/neo4j-ruby-driver_loader.rb#19
    def load; end
  end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/logging1.rb#3
module Neo4j::Driver::Logging1
  private

  # @param level the log level.
  # @return new logging implementation.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/logging1.rb#39
  def console(level); end

  # @param level the log level.
  # @return new logging implementation.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/logging1.rb#31
  def java_util_logging(level); end

  # source://neo4j-ruby-driver//ruby/neo4j/driver/logging1.rb#10
  def log(clazz); end

  # @return new logging implementation.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/logging1.rb#46
  def none; end

  # @return new logging implementation.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/logging1.rb#19
  def slf4j; end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver.rb#0
module Neo4j::Driver::Net; end

# source://neo4j-ruby-driver//ruby/neo4j/driver/net/server_address.rb#3
module Neo4j::Driver::Net::ServerAddress
  class << self
    # source://neo4j-ruby-driver//ruby/neo4j/driver/net/server_address.rb#4
    def of(host, port); end
  end
end

# @see Session
# @see Transaction
# @see Result
# @see Result#consume()
# @see ResultSummary
# @since 1.0
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/query.rb#11
class Neo4j::Driver::Query < ::Struct
  # @return [Query] a new instance of Query
  # @since 1.0
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/query.rb#12
  def initialize(text, **parameters); end

  # @since 1.0
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/query.rb#22
  def with_parameters(new_parameters); end

  # @param newText the new query text
  # @return a new Query object with updated text
  # @since 1.0
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/query.rb#18
  def with_text(new_text); end

  # @param updates describing how to update the parameters
  # @return a new query with updated parameters
  # @since 1.0
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/query.rb#35
  def with_updated_parameters(**updates); end

  class << self
    # @since 1.0
    #
    # source://neo4j-ruby-driver//ruby/neo4j/driver/query.rb#41
    def validated_query_text(query); end
  end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver.rb#17
Neo4j::Driver::Record = Neo4j::Driver::Internal::InternalRecord

# @see Result#list()
# @since 1.0
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/records.rb#7
class Neo4j::Driver::Records
  class << self
    # @since 1.0
    #
    # source://neo4j-ruby-driver//ruby/neo4j/driver/records.rb#8
    def column(index, map_function); end
  end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver.rb#18
Neo4j::Driver::Result = Neo4j::Driver::Internal::InternalResult

# source://neo4j-ruby-driver//ruby/neo4j/driver.rb#0
module Neo4j::Driver::Summary; end

# source://neo4j-ruby-driver//lib/neo4j/driver/summary/query_type.rb#4
module Neo4j::Driver::Summary::QueryType; end

# source://neo4j-ruby-driver//lib/neo4j/driver/summary/query_type.rb#5
Neo4j::Driver::Summary::QueryType::READ_ONLY = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//lib/neo4j/driver/summary/query_type.rb#6
Neo4j::Driver::Summary::QueryType::READ_WRITE = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//lib/neo4j/driver/summary/query_type.rb#8
Neo4j::Driver::Summary::QueryType::SCHEMA_WRITE = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//lib/neo4j/driver/summary/query_type.rb#7
Neo4j::Driver::Summary::QueryType::WRITE_ONLY = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//lib/neo4j/driver/synchronizable.rb#5
module Neo4j::Driver::Synchronizable
  # source://neo4j-ruby-driver//lib/neo4j/driver/synchronizable.rb#6
  def sync(*methods); end

  private

  # source://neo4j-ruby-driver//lib/neo4j/driver/synchronizable.rb#12
  def with_sync_wrapper(methods); end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver.rb#19
Neo4j::Driver::Transaction = Neo4j::Driver::Internal::InternalTransaction

# Configuration object containing settings for transactions.
# Instances are immutable and can be reused for multiple transactions.
# <p>
# Configuration is supported for:
# <ul>
# <li>queries executed in auto-commit transactions - using various overloads of {@link Session#run(String, TransactionConfig)} and
# {@link AsyncSession#runAsync(String, TransactionConfig)}</li>
# <li>transactions started by transaction functions - using {@link Session#readTransaction(TransactionWork, TransactionConfig)},
# {@link Session#writeTransaction(TransactionWork, TransactionConfig)}, {@link AsyncSession#readTransactionAsync(AsyncTransactionWork, TransactionConfig)} and
# {@link AsyncSession#writeTransactionAsync(AsyncTransactionWork, TransactionConfig)}</li>
# <li>unmanaged transactions - using {@link Session#beginTransaction(TransactionConfig)} and {@link AsyncSession#beginTransactionAsync(TransactionConfig)}</li>
# </ul>
# <p>
# Creation of configuration objects can be done using the builder API:
# <pre>
# {@code
# Map<String, Object> metadata = new HashMap<>();
# metadata.put("type", "update user");
# metadata.put("application", "my application");
#  TransactionConfig config = TransactionConfig.builder()
#                  .withTimeout(Duration.ofSeconds(4))
#                  .withMetadata(metadata)
#                  .build();
#  }
#  </pre>
#
# @see Session
#
# source://neo4j-ruby-driver//ruby/neo4j/driver/transaction_config.rb#29
class Neo4j::Driver::TransactionConfig < ::Hash
  # @return [TransactionConfig] a new instance of TransactionConfig
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/transaction_config.rb#32
  def initialize(timeout: T.unsafe(nil), metadata: T.unsafe(nil)); end

  # @return [@code true] when no values are configured, {@code false otherwise}.
  #
  # source://neo4j-ruby-driver//ruby/neo4j/driver/transaction_config.rb#45
  def empty?; end

  class << self
    # source://neo4j-ruby-driver//ruby/neo4j/driver/transaction_config.rb#38
    def empty; end
  end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/transaction_config.rb#30
Neo4j::Driver::TransactionConfig::EMPTY = T.let(T.unsafe(nil), Neo4j::Driver::TransactionConfig)

# source://neo4j-ruby-driver//ruby/neo4j/driver.rb#0
module Neo4j::Driver::Types; end

# source://neo4j-ruby-driver//ruby/neo4j/driver.rb#22
Neo4j::Driver::Types::Entity = Neo4j::Driver::Internal::InternalEntity

# source://neo4j-ruby-driver//lib/neo4j/driver/types/local_date_time.rb#6
class Neo4j::Driver::Types::LocalDateTime < ::Neo4j::Driver::Types::Time
  # source://neo4j-ruby-driver//lib/neo4j/driver/types/local_date_time.rb#15
  def day(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//lib/neo4j/driver/types/local_date_time.rb#15
  def hour(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//lib/neo4j/driver/types/local_date_time.rb#15
  def min(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//lib/neo4j/driver/types/local_date_time.rb#15
  def month(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//lib/neo4j/driver/types/local_date_time.rb#15
  def nsec(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//lib/neo4j/driver/types/local_date_time.rb#15
  def sec(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//lib/neo4j/driver/types/local_date_time.rb#16
  def to_i(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//lib/neo4j/driver/types/local_date_time.rb#15
  def year(*_arg0, **_arg1, &_arg2); end

  class << self
    # source://neo4j-ruby-driver//lib/neo4j/driver/types/local_date_time.rb#10
    def significant_fields; end
  end
end

# source://neo4j-ruby-driver//lib/neo4j/driver/types/local_time.rb#6
class Neo4j::Driver::Types::LocalTime < ::Neo4j::Driver::Types::Time
  # source://neo4j-ruby-driver//lib/neo4j/driver/types/local_time.rb#15
  def hour(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//lib/neo4j/driver/types/local_time.rb#15
  def min(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//lib/neo4j/driver/types/local_time.rb#15
  def nsec(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//lib/neo4j/driver/types/local_time.rb#15
  def sec(*_arg0, **_arg1, &_arg2); end

  class << self
    # source://neo4j-ruby-driver//lib/neo4j/driver/types/local_time.rb#10
    def significant_fields; end
  end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver.rb#23
Neo4j::Driver::Types::Node = Neo4j::Driver::Internal::InternalNode

# source://neo4j-ruby-driver//lib/neo4j/driver/types/offset_time.rb#6
class Neo4j::Driver::Types::OffsetTime < ::Neo4j::Driver::Types::Time
  # source://neo4j-ruby-driver//lib/neo4j/driver/types/offset_time.rb#15
  def hour(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//lib/neo4j/driver/types/offset_time.rb#15
  def min(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//lib/neo4j/driver/types/offset_time.rb#15
  def nsec(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//lib/neo4j/driver/types/offset_time.rb#15
  def sec(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//lib/neo4j/driver/types/offset_time.rb#15
  def utc_offset(*_arg0, **_arg1, &_arg2); end

  class << self
    # source://neo4j-ruby-driver//lib/neo4j/driver/types/offset_time.rb#10
    def significant_fields; end
  end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver.rb#24
Neo4j::Driver::Types::Path = Neo4j::Driver::Internal::InternalPath

# source://neo4j-ruby-driver//lib/neo4j/driver/types/point.rb#6
class Neo4j::Driver::Types::Point
  # @return [Point] a new instance of Point
  #
  # source://neo4j-ruby-driver//lib/neo4j/driver/types/point.rb#16
  def initialize(args); end

  # source://neo4j-ruby-driver//lib/neo4j/driver/types/point.rb#23
  def coordinates; end

  # Returns the value of attribute srid.
  #
  # source://neo4j-ruby-driver//lib/neo4j/driver/types/point.rb#7
  def srid; end

  # Sets the attribute srid
  #
  # @param value the value to set the attribute srid to.
  #
  # source://neo4j-ruby-driver//lib/neo4j/driver/types/point.rb#7
  def srid=(_arg0); end

  # Returns the value of attribute x.
  #
  # source://neo4j-ruby-driver//lib/neo4j/driver/types/point.rb#7
  def x; end

  # Sets the attribute x
  #
  # @param value the value to set the attribute x to.
  #
  # source://neo4j-ruby-driver//lib/neo4j/driver/types/point.rb#7
  def x=(_arg0); end

  # Returns the value of attribute y.
  #
  # source://neo4j-ruby-driver//lib/neo4j/driver/types/point.rb#7
  def y; end

  # Sets the attribute y
  #
  # @param value the value to set the attribute y to.
  #
  # source://neo4j-ruby-driver//lib/neo4j/driver/types/point.rb#7
  def y=(_arg0); end

  # Returns the value of attribute z.
  #
  # source://neo4j-ruby-driver//lib/neo4j/driver/types/point.rb#7
  def z; end

  # Sets the attribute z
  #
  # @param value the value to set the attribute z to.
  #
  # source://neo4j-ruby-driver//lib/neo4j/driver/types/point.rb#7
  def z=(_arg0); end

  private

  # source://neo4j-ruby-driver//lib/neo4j/driver/types/point.rb#29
  def implied_crs(geo); end
end

# source://neo4j-ruby-driver//lib/neo4j/driver/types/point.rb#9
Neo4j::Driver::Types::Point::SRID = T.let(T.unsafe(nil), ActiveSupport::HashWithIndifferentAccess)

# source://neo4j-ruby-driver//ruby/neo4j/driver.rb#25
Neo4j::Driver::Types::Relationship = Neo4j::Driver::Internal::InternalRelationship

# source://neo4j-ruby-driver//lib/neo4j/driver/types/time.rb#6
class Neo4j::Driver::Types::Time
  include ::Comparable

  # @return [Time] a new instance of Time
  #
  # source://neo4j-ruby-driver//lib/neo4j/driver/types/time.rb#17
  def initialize(time); end

  # source://neo4j-ruby-driver//lib/neo4j/driver/types/time.rb#39
  def +(numeric); end

  # source://neo4j-ruby-driver//lib/neo4j/driver/types/time.rb#25
  def <=>(other); end

  # source://neo4j-ruby-driver//lib/neo4j/driver/types/time.rb#33
  def ==(other); end

  # source://neo4j-ruby-driver//lib/neo4j/driver/types/time.rb#33
  def eql?(other); end

  # source://neo4j-ruby-driver//lib/neo4j/driver/types/time.rb#9
  def hash(*_arg0, **_arg1, &_arg2); end

  # source://neo4j-ruby-driver//lib/neo4j/driver/types/time.rb#21
  def significant; end

  # source://neo4j-ruby-driver//lib/neo4j/driver/types/time.rb#9
  def to_a(*_arg0, **_arg1, &_arg2); end

  class << self
    # source://neo4j-ruby-driver//lib/neo4j/driver/types/time.rb#12
    def parse(date); end
  end
end

# source://neo4j-ruby-driver//ruby/neo4j/driver/version.rb#5
Neo4j::Driver::VERSION = T.let(T.unsafe(nil), String)

# source://neo4j-ruby-driver//ruby/neo4j/driver/values.rb#3
module Neo4j::Driver::Values
  class << self
    # @raise [Exceptions::ClientException]
    #
    # source://neo4j-ruby-driver//ruby/neo4j/driver/values.rb#21
    def nonconvertible(value); end

    # source://neo4j-ruby-driver//ruby/neo4j/driver/values.rb#4
    def value(value); end
  end
end
